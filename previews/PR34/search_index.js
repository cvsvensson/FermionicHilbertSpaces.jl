var documenterSearchIndex = {"docs":
[{"location":"misc/#Misc","page":"Misc","title":"Misc","text":"","category":"section"},{"location":"misc/#Subregion","page":"Misc","title":"Subregion","text":"","category":"section"},{"location":"misc/","page":"Misc","title":"Misc","text":"The function subregion can be used to extract the Hilbert space of a subregion.","category":"page"},{"location":"misc/","page":"Misc","title":"Misc","text":"using FermionicHilbertSpaces\nH = hilbert_space(1:4)\nHsub = subregion(1:2, H)","category":"page"},{"location":"misc/","page":"Misc","title":"Misc","text":"When the Hilbert space has a restricted set of fock states, the Hilbert space of the subregion will only include fock states compatible with this restriction. In the example below, the total number of particles 1, and the subregion will have three possible states: (1,0), (0,1), and (0,0).","category":"page"},{"location":"misc/","page":"Misc","title":"Misc","text":"H = hilbert_space(1:4, FermionConservation(1))\nHsub = subregion(1:2, H)\nbasisstates(Hsub)","category":"page"},{"location":"misc/#No-double-occupation","page":"Misc","title":"No double occupation","text":"","category":"section"},{"location":"misc/","page":"Misc","title":"Misc","text":"The following example demonstrates how to restrict the Hilbert space to only allow single occupation of a site, which can be useful for simulating systems where the on-site coulomb interaction is strong enough to prevent double occupation.","category":"page"},{"location":"misc/","page":"Misc","title":"Misc","text":"using FermionicHilbertSpaces, LinearAlgebra\nN = 2 # number of fermions\nspace = 1:N \nspin = (:↑,:↓)\n# labels = Base.product(space, spin) \nHs = [hilbert_space([(k, s) for s in spin], FermionConservation(0:1)) for k in space]\nH = tensor_product(Hs)","category":"page"},{"location":"misc/","page":"Misc","title":"Misc","text":"size(H,1) == 3^N","category":"page"},{"location":"misc/","page":"Misc","title":"Misc","text":"Can also take product of symmetries","category":"page"},{"location":"misc/","page":"Misc","title":"Misc","text":"qn2 = prod(IndexConservation(k,0:1) for k in space)\nH2 = hilbert_space(keys(H), qn2)","category":"page"},{"location":"misc/","page":"Misc","title":"Misc","text":"This gives the same states but with a different ordering.","category":"page"},{"location":"misc/","page":"Misc","title":"Misc","text":"sort(basisstates(H2), by = f->f.f) == sort(basisstates(H), by = f->f.f)","category":"page"},{"location":"literate_output/kitaev_chain/#Interacting-Kitaev-Chain-Tutorial","page":"Interacting Kitaev chain","title":"Interacting Kitaev Chain Tutorial","text":"","category":"section"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"In this example, we study the interacting Kitaev chain. We show how the Hamiltonian can be constructed symbolically or by using matrix representations of the fermionic operators, and how to restrict the Hilbert space to a subspace of a given parity. We solve for the ground states and characterize the locality of the many-body Majoranas.","category":"page"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"We start by importing the necessary packages.","category":"page"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"using FermionicHilbertSpaces, LinearAlgebra, Plots\nusing Arpack","category":"page"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"Then we define the Hilbert space with N sites and parity conservation.","category":"page"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"N = 12\nH = hilbert_space(1:N, ParityConservation())","category":"page"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"Symbolic fermions can be defined using the @fermions macro,","category":"page"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"@fermions f","category":"page"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"Let's define the interacting Kitaev chain Hamiltonian. It is a function of the fermions f and parameters N, μ, t, Δ, and U, representing the number of sites, chemical potential, hopping amplitude, pairing amplitude, and interaction strength, respectively. Note the use of the Hermitian conjugate hc, which simplifies the expression for the Hamiltonian.","category":"page"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"kitaev_chain(f, N, μ, t, Δ, U) = sum(t * f[i]' * f[i+1] + hc for i in 1:N-1) +\n                                 sum(Δ * f[i] * f[i+1] + hc for i in 1:N-1) +\n                                 sum(U * f[i]' * f[i] * f[i+1]' * f[i+1] for i in 1:N-1) +\n                                 sum(μ[i] * f[i]' * f[i] for i in 1:N)","category":"page"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"Define parameters close to the sweet spot with perfectly localized Majoranas.","category":"page"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"U = 4.0\nt = 1.0\nδΔ = 0.4\nΔ = t + U / 2 - δΔ # slightly detuned from the sweet spot\nμ = fill(-U / 2, N) # edge chemical potential\nμ[2:N-1] .= -U # bulk chemical potential","category":"page"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"We can now construct the Hamiltonian using symbolic fermions for a symbolic representation","category":"page"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"hsym = kitaev_chain(f, N, μ, t, Δ, U)","category":"page"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"To convert the symbolic Hamiltonian to a matrix representation, we can use the matrix_representation function.","category":"page"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"matrix_representation(hsym, H)","category":"page"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"Now, let's diagonalize the system. Since parity is conserved, we can work in the even and odd parity sectors separately. To do this, we can create two new Hilbert spaces for the even and odd sectors","category":"page"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"Heven = hilbert_space(1:N, ParityConservation(1))\nHodd = hilbert_space(1:N, ParityConservation(-1))\nheven = matrix_representation(hsym, Heven)\nhodd = matrix_representation(hsym, Hodd)","category":"page"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"and then diagonalize each sector separately.","category":"page"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"oddeigs = eigs(hodd; nev=1, which=:SR)\neveneigs = eigs(heven; nev=1, which=:SR)\noddvec = oddeigs[2][:, 1] # odd ground state\nevenvec = eveneigs[2][:, 1] # even ground state","category":"page"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"The ground states are almost degenerate, as expected.","category":"page"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"first(oddeigs[1]) - first(eveneigs[1])","category":"page"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"Now, we construct the ground state Majoranas. First, we need to embed the lowest energy odd and even states into the full Hilbert space.","category":"page"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"function extend(v, p)\n    mapreduce(H -> H == first(p) ? v : zeros(size(H, 1)), vcat, last(p))\nend\n\nHsum = (Hodd, Heven)\no = extend(oddvec, Hodd => Hsum) # odd ground state in the full Hilbert space\ne = extend(evenvec, Heven => Hsum) # even ground state in the full Hilbert space","category":"page"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"Then, we can construct the ground state Majorana operators as γ = o * e' + hc γ̃ = 1im * o * e' + hc but that takes a lot of memory for large systems. Let's make a quick struct representing a rank-1 matrix and use that instead.","category":"page"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"struct Rank1Matrix{T} <: AbstractMatrix{T}\n    vec1::Vector{T}\n    vec2::Vector{T}\nend\nBase.getindex(m::Rank1Matrix, i::Int, j::Int) = m.vec1[i] * conj(m.vec2[j])\nBase.size(m::Rank1Matrix) = (length(m.vec1), length(m.vec2))\n\noe = Rank1Matrix(o, e)\nee = Rank1Matrix(e, e)\noo = Rank1Matrix(o, o)","category":"page"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"Now we can compute the reduction of the Majorana operators to each mode.","category":"page"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"Hmodes = [hilbert_space(i:i) for i in 1:N]\neoR = [partial_trace(oe, H => Hmode) for Hmode in Hmodes];\neeR = [partial_trace(ee, H => Hmode) for Hmode in Hmodes];\nooR = [partial_trace(oo, H => Hmode) for Hmode in Hmodes];\nγ_reductions = [norm(svdvals(eoR + hc), 1) for eoR in eoR]\nγ̃_reductions = [norm(svdvals(1im * eoR + hc), 1) for eoR in eoR]\nLD = [norm(svdvals(ooR - eeR), 1) for (ooR, eeR) in zip(ooR, eeR)]","category":"page"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"We can plot the reductions to visualize the localization of the Majorana modes.","category":"page"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"#\nlw = 4\nlegendfontsize = 15\nmarker = true\nmarkerstrokewidth = 2\nplot(xlabel=\"Site\", title=\"Majorana quality measures\"; frame=:box, size=(500, 300), xticks=1:3:N, yscale=:identity, legendfontsize, ylims=(-1e-1, 2), legendposition=:top, labelfontsize=15)\nplot!(1:N, γ_reductions; label=\"‖γₙ‖\", lw, legendfontsize, marker, markerstrokewidth)\nplot!(1:N, γ̃_reductions; label=\"‖γ̃ₙ‖\", lw, legendfontsize, marker, markerstrokewidth)\nplot!(1:N, LD; label=\"‖(iγγ̃)ₙ‖\", lw, legendfontsize, marker, markerstrokewidth)","category":"page"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"","category":"page"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#FermionicHilbertSpaces.jl","page":"Home","title":"FermionicHilbertSpaces.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"FermionicHilbertSpaces.jl is a Julia package for defining fermionic Hilbert spaces and operators. The central features are fermionic tensor products and partial traces, which differ from the standard tensor product since fermions anticommute.  [1] ","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg; Pkg.add(url=\"https://github.com/cvsvensson/FermionicHilbertSpaces.jl\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"or by adding a registry to your julia environment and then installing the package","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg; Pkg.Registry.add(RegistrySpec(url = \"https://github.com/williamesamuelson/PackageRegistry\"))\nPkg.add(\"FermionicHilbertSpaces\")","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following example demonstrates how to define a fermionic Hilbert space, create fermionic operators, and construct a simple Hamiltonian:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using FermionicHilbertSpaces, LinearAlgebra\nN = 2 # number of fermions\nspatial_labels = 1:N \ninternal_labels = (:↑,:↓)\nlabels = Base.product(spatial_labels, internal_labels) \nH = hilbert_space(labels) ","category":"page"},{"location":"","page":"Home","title":"Home","text":"c = fermions(H) # fermionic annihilation operators","category":"page"},{"location":"#Define-a-simple-Hamiltonian-from-the-fermionic-operators","page":"Home","title":"Define a simple Hamiltonian from the fermionic operators","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"H_hopping = c[1,:↑]'c[2,:↑] + c[1,:↓]'c[2,:↓] + hc \nH_coulomb = sum(c[n,:↑]'c[n,:↑]c[n,:↓]'c[n,:↓] for n in spatial_labels)\nH_hopping + H_coulomb","category":"page"},{"location":"#Defining-a-symbolic-hamiltonian","page":"Home","title":"Defining a symbolic hamiltonian","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"@fermions f \nmatrix_representation(f[1,:↑]'*f[1,:↑], H)","category":"page"},{"location":"#Tensor-product-and-partial-trace","page":"Home","title":"Tensor product and partial trace","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"H1 = hilbert_space(1:2)\nH2 = hilbert_space(3:4)\nH = tensor_product(H1, H2)\nc1,c2,c = fermions(H1), fermions(H2), fermions(H)\nc1c3 = tensor_product([c1[1], c2[3]], [H1, H2] => H)\nc[1]*c[3] == c1c3","category":"page"},{"location":"","page":"Home","title":"Home","text":"partial_trace(tensor_product([c1[1], I/4], [H1, H2] => H), H => H1) == c1[1] ","category":"page"},{"location":"#Conserved-quantum-numbers","page":"Home","title":"Conserved quantum numbers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"H = hilbert_space([1,2], ParityConservation())","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<a name=\"fermion_information_article\"></a>","category":"page"},{"location":"","page":"Home","title":"Home","text":"[1] Szalay, Szilárd, et al. \"Fermionic systems for quantum information people.\" Journal of Physics A: Mathematical and Theoretical 54.39 (2021): 393001, arXiv:2006.03087","category":"page"},{"location":"docstrings/#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"docstrings/","page":"Functions","title":"Functions","text":"","category":"page"},{"location":"docstrings/#Docstrings","page":"Functions","title":"Docstrings","text":"","category":"section"},{"location":"docstrings/#FermionicHilbertSpaces.FermionConservation","page":"Functions","title":"FermionicHilbertSpaces.FermionConservation","text":"FermionConservation\n\nA symmetry type representing conservation of total fermion number.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#FermionicHilbertSpaces.FockHilbertSpace","page":"Functions","title":"FermionicHilbertSpaces.FockHilbertSpace","text":"FockHilbertSpace\n\nA type representing a Fock Hilbert space with a given set of modes and Fock states.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#FermionicHilbertSpaces.FockNumber","page":"Functions","title":"FermionicHilbertSpaces.FockNumber","text":"FockNumber\n\nA type representing a Fock state as the bitstring of an integer.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#FermionicHilbertSpaces.FockSymmetry","page":"Functions","title":"FermionicHilbertSpaces.FockSymmetry","text":"struct FockSymmetry{IF,FI,QN,QNfunc} <: AbstractSymmetry\n\nFockSymmetry represents a symmetry that is diagonal in fock space, i.e. particle number conservation, parity, spin consvervation.\n\nFields\n\nbasisstates::IF: A vector of Fock numbers, which are integers representing the occupation of each mode.\nstate_indexdict::FI: A dictionary mapping Fock states to indices.\nqntofockstates::Dictionary{QN,Vector{Int}}: A dictionary mapping quantum numbers to Fock states.\nconserved_quantity::QNfunc: A function that computes the conserved quantity from a fock number.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#FermionicHilbertSpaces.HC","page":"Functions","title":"FermionicHilbertSpaces.HC","text":"HC\n\nRepresents the Hermitian conjugate.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#FermionicHilbertSpaces.IndexConservation","page":"Functions","title":"FermionicHilbertSpaces.IndexConservation","text":"IndexConservation\n\nA symmetry type representing conservation of the numbers of modes which contains a specific index or set of indices.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#FermionicHilbertSpaces.JordanWignerOrdering","page":"Functions","title":"FermionicHilbertSpaces.JordanWignerOrdering","text":"JordanWignerOrdering\n\nA type representing the ordering of fermionic modes.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#FermionicHilbertSpaces.NoSymmetry","page":"Functions","title":"FermionicHilbertSpaces.NoSymmetry","text":"NoSymmetry\n\nA symmetry type indicating no symmetry constraints.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#FermionicHilbertSpaces.ParityConservation","page":"Functions","title":"FermionicHilbertSpaces.ParityConservation","text":"ParityConservation\n\nA symmetry type representing conservation of fermion parity.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#FermionicHilbertSpaces.SimpleFockHilbertSpace","page":"Functions","title":"FermionicHilbertSpaces.SimpleFockHilbertSpace","text":"SimpleFockHilbertSpace\n\nA type representing a simple Fock Hilbert space with all fock states included.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#FermionicHilbertSpaces.SymmetricFockHilbertSpace","page":"Functions","title":"FermionicHilbertSpaces.SymmetricFockHilbertSpace","text":"SymmetricFockHilbertSpace\n\nA type representing a Fock Hilbert space with fockstates organized by their quantum number.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#FermionicHilbertSpaces.basisstates-Tuple{SimpleFockHilbertSpace}","page":"Functions","title":"FermionicHilbertSpaces.basisstates","text":"basisstates(H)\n\nReturn an iterator over all basis states for the given Hilbert space H.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#FermionicHilbertSpaces.embedding","page":"Functions","title":"FermionicHilbertSpaces.embedding","text":"embedding(m, H, Hnew)\n\nCompute the fermionic embedding of a matrix m in the basis Hsub into the basis H.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#FermionicHilbertSpaces.embedding_unitary-Tuple{Any, Any, JordanWignerOrdering}","page":"Functions","title":"FermionicHilbertSpaces.embedding_unitary","text":"embedding_unitary(partition, basisstates, jw)\n\nCompute the unitary matrix that maps between the tensor embedding and the fermionic embedding in the physical subspace. \n# Arguments\n- `partition`: A partition of the labels in `jw` into disjoint sets.\n- `basisstates`: The basis states in the basis\n- `jw`: The Jordan-Wigner ordering.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#FermionicHilbertSpaces.eval_in_basis-Tuple{FermionicHilbertSpaces.FermionSym, Any}","page":"Functions","title":"FermionicHilbertSpaces.eval_in_basis","text":"eval_in_basis(a, f)\n\nEvaluate an expression with fermions in a basis f. \n\nExamples\n\n@fermions a\nf = fermions(hilbert_space(1:2))\nFermionicHilbertSpaces.eval_in_basis(a[1]'*a[2] + hc, f)\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#FermionicHilbertSpaces.extension","page":"Functions","title":"FermionicHilbertSpaces.extension","text":"extension(m, H, Hbar[, phase_factors])\n\nExtend an operator or state m from Hilbert space H into a disjoint space Hbar.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#FermionicHilbertSpaces.fermion_sparse_matrix-Tuple{Any, FermionicHilbertSpaces.AbstractFockHilbertSpace}","page":"Functions","title":"FermionicHilbertSpaces.fermion_sparse_matrix","text":"fermion_sparse_matrix(fermion_number, H::AbstractFockHilbertSpace)\n\nConstructs a sparse matrix of size representing a fermionic annihilation operator at bit position fermion_number on the Hilbert space H. \n\n\n\n\n\n","category":"method"},{"location":"docstrings/#FermionicHilbertSpaces.fermion_to_majorana","page":"Functions","title":"FermionicHilbertSpaces.fermion_to_majorana","text":"fermion_to_majorana(expr)\n\nConvert symbolic fermions to symbolic majoranas.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#FermionicHilbertSpaces.fermionic_kron","page":"Functions","title":"FermionicHilbertSpaces.fermionic_kron","text":"fermionic_kron(ms, Hs, H::AbstractHilbertSpace=tensor_product(Hs))\n\nCompute the fermionic tensor product of matrices or vectors in ms with respect to the spaces Hs, respectively. Return a matrix in the space H, which defaults to the tensor_product product of Hs.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#FermionicHilbertSpaces.fermions-Tuple{FermionicHilbertSpaces.AbstractFockHilbertSpace}","page":"Functions","title":"FermionicHilbertSpaces.fermions","text":"fermions(H)\n\nReturn a dictionary of fermionic annihilation operators for the Hilbert space H.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#FermionicHilbertSpaces.fixed_particle_number_fockstates-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T","page":"Functions","title":"FermionicHilbertSpaces.fixed_particle_number_fockstates","text":"fixed_particle_number_fockstates(M, n)\n\nGenerate a list of Fock states with n occupied fermions in a system with M different fermions.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#FermionicHilbertSpaces.focksymmetry-Tuple{Any, Any}","page":"Functions","title":"FermionicHilbertSpaces.focksymmetry","text":"focksymmetry(basisstates, qn)\n\nConstructs a FockSymmetry object that represents the symmetry of a many-body system. \n\nArguments\n\nbasisstates: The basisstates to iterate over\nqn: A function that takes an integer representing a fock state and returns corresponding quantum number.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#FermionicHilbertSpaces.hilbert_space-Tuple{Any}","page":"Functions","title":"FermionicHilbertSpaces.hilbert_space","text":"hilbert_space(labels[, symmetry, basisstates])\n\nConstruct a Hilbert space from a set of labels, with optional symmetry and Fock number specification.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#FermionicHilbertSpaces.jwstring-Tuple{Any, Any}","page":"Functions","title":"FermionicHilbertSpaces.jwstring","text":"jwstring(site, focknbr)\n\nParity of the number of fermions to the right of site.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#FermionicHilbertSpaces.majorana_to_fermion","page":"Functions","title":"FermionicHilbertSpaces.majorana_to_fermion","text":"majorana_to_fermion(expr)\n\nConvert symbolic majoranas to symbolic fermions.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#FermionicHilbertSpaces.majoranas","page":"Functions","title":"FermionicHilbertSpaces.majoranas","text":"majoranas(H)\n\nReturn a dictionary of Majorana operators for the Hilbert space H.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#FermionicHilbertSpaces.numberoperator-Tuple{FermionicHilbertSpaces.AbstractFockHilbertSpace}","page":"Functions","title":"FermionicHilbertSpaces.numberoperator","text":"numberoperator(H)\n\nReturn the number operator for the Hilbert space H.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#FermionicHilbertSpaces.parityoperator-Tuple{FermionicHilbertSpaces.AbstractFockHilbertSpace}","page":"Functions","title":"FermionicHilbertSpaces.parityoperator","text":"parityoperator(H)\n\nReturn the fermionic parity operator for the Hilbert space H.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#FermionicHilbertSpaces.partial_trace!","page":"Functions","title":"FermionicHilbertSpaces.partial_trace!","text":"partial_trace!(mout, m::AbstractMatrix, H::AbstractHilbertSpace, Hout::AbstractHilbertSpace, phase_factors)\n\nCompute the fermionic partial trace of a matrix m in basis H, leaving only the subsystems specified by labels. The result is stored in mout, and Hout determines the ordering of the basis states.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#FermionicHilbertSpaces.partial_trace-Union{Tuple{T}, Tuple{AbstractMatrix{T}, FermionicHilbertSpaces.AbstractHilbertSpace, FermionicHilbertSpaces.AbstractHilbertSpace}, Tuple{AbstractMatrix{T}, FermionicHilbertSpaces.AbstractHilbertSpace, FermionicHilbertSpaces.AbstractHilbertSpace, Bool}} where T","page":"Functions","title":"FermionicHilbertSpaces.partial_trace","text":"partial_trace(m::AbstractMatrix,  bHfull::AbstractHilbertSpace, Hsub::AbstractHilbertSpace)\n\nCompute the partial trace of a matrix m, leaving the subsystem defined by the basis bsub.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#FermionicHilbertSpaces.removefermion-Tuple{Any, FockNumber}","page":"Functions","title":"FermionicHilbertSpaces.removefermion","text":"removefermion(digitposition, f::FockNumber)\n\nReturn (newfocknbr, fermionstatistics) where newfocknbr is the state obtained by removing a fermion at digitposition from f and fermionstatistics is the phase from the Jordan-Wigner string, or 0 if the operation is not allowed.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#FermionicHilbertSpaces.subregion-Tuple{Any, SimpleFockHilbertSpace}","page":"Functions","title":"FermionicHilbertSpaces.subregion","text":"subregion(modes, H::AbstractHilbertSpace)\n\nReturn a subregion of the Hilbert space H that is spanned by the modes in modes. Only substates in H are included.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#FermionicHilbertSpaces.tensor_product","page":"Functions","title":"FermionicHilbertSpaces.tensor_product","text":"tensor_product(ms, Hs, H::AbstractHilbertSpace, phase_factors=true)\n\nCompute the ordered product of the fermionic embeddings of the matrices ms in the spaces Hs into the space H.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#FermionicHilbertSpaces.tensor_product-Tuple{AbstractVector{<:FermionicHilbertSpaces.AbstractHilbertSpace}}","page":"Functions","title":"FermionicHilbertSpaces.tensor_product","text":"tensor_product(Hs)\n\nCompute the tensorproduct product hilbert spaces Hs. The symmetry of the resulting basis is computed by promotesymmetry.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#FermionicHilbertSpaces.@fermions-Tuple","page":"Functions","title":"FermionicHilbertSpaces.@fermions","text":"@fermions a b ...\n\nCreate one or more fermion species with the given names. Indexing into fermions species gives a concrete fermion. Fermions in one @fermions block anticommute with each other,  and commute with fermions in other @fermions blocks.\n\nExamples:\n\n@fermions a b creates two species of fermions that anticommute:\na[1]' * a[1] + a[1] * a[1]' == 1\na[1]' * b[1] + b[1] * a[1]' == 0\n@fermions a; @fermions b creates two species of fermions that commute with each other:\na[1]' * a[1] + a[1] * a[1]' == 1\na[1] * b[1] - b[1] * a[1] == 0\n\nSee also @majoranas, FermionicHilbertSpaces.eval_in_basis.\n\n\n\n\n\n","category":"macro"},{"location":"docstrings/#FermionicHilbertSpaces.@majoranas-Tuple","page":"Functions","title":"FermionicHilbertSpaces.@majoranas","text":"@majoranas a b ...\n\nCreate one or more Majorana species with the given names. Indexing into Majorana species gives a concrete Majorana. Majoranas in one @majoranas block anticommute with each other, and commute with Majoranas in other @majoranas blocks.\n\nExamples:\n\n@majoranas a b creates two species of Majoranas that anticommute:\na[1] * a[1] + a[1] * a[1] == 1\na[1] * b[1] + b[1] * a[1] == 0\n@majoranas a; @majoranas b creates two species of Majoranas that commute with each other:\na[1] * a[1] + a[1] * a[1] == 1\na[1] * b[1] - b[1] * a[1] == 0\n\nSee also @fermions, FermionicHilbertSpaces.eval_in_basis.\n\n\n\n\n\n","category":"macro"}]
}
