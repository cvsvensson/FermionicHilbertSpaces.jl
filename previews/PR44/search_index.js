var documenterSearchIndex = {"docs":
[{"location":"misc/#Misc","page":"Misc","title":"Misc","text":"","category":"section"},{"location":"misc/#Subregion","page":"Misc","title":"Subregion","text":"","category":"section"},{"location":"misc/","page":"Misc","title":"Misc","text":"The function subregion can be used to extract the Hilbert space of a subregion.","category":"page"},{"location":"misc/","page":"Misc","title":"Misc","text":"using FermionicHilbertSpaces\nH = hilbert_space(1:4)\nHsub = subregion(1:2, H)","category":"page"},{"location":"misc/","page":"Misc","title":"Misc","text":"When the Hilbert space has a restricted set of fock states, the Hilbert space of the subregion will only include fock states compatible with this restriction. In the example below, the total number of particles 1, and the subregion will have three possible states: (1,0), (0,1), and (0,0).","category":"page"},{"location":"misc/","page":"Misc","title":"Misc","text":"H = hilbert_space(1:4, FermionConservation(1))\nHsub = subregion(1:2, H)\nbasisstates(Hsub)","category":"page"},{"location":"misc/#No-double-occupation","page":"Misc","title":"No double occupation","text":"","category":"section"},{"location":"misc/","page":"Misc","title":"Misc","text":"The following example demonstrates how to restrict the Hilbert space to only allow single occupation of a site, which can be useful for simulating systems where the on-site coulomb interaction is strong enough to prevent double occupation.","category":"page"},{"location":"misc/","page":"Misc","title":"Misc","text":"using FermionicHilbertSpaces, LinearAlgebra\nN = 2 # number of fermions\nspace = 1:N \nspin = (:↑,:↓)\n# labels = Base.product(space, spin) \nHs = [hilbert_space([(k, s) for s in spin], FermionConservation(0:1)) for k in space]\nH = tensor_product(Hs)","category":"page"},{"location":"misc/","page":"Misc","title":"Misc","text":"size(H,1) == 3^N","category":"page"},{"location":"misc/","page":"Misc","title":"Misc","text":"Can also take product of symmetries","category":"page"},{"location":"misc/","page":"Misc","title":"Misc","text":"qn2 = prod(IndexConservation(k,0:1) for k in space)\nH2 = hilbert_space(keys(H), qn2)","category":"page"},{"location":"misc/","page":"Misc","title":"Misc","text":"This gives the same states but with a different ordering.","category":"page"},{"location":"misc/","page":"Misc","title":"Misc","text":"sort(basisstates(H2)) == sort(basisstates(H))","category":"page"},{"location":"non_interacting/#Non-interacting-hamiltonians","page":"Non interacting systems","title":"Non-interacting hamiltonians","text":"","category":"section"},{"location":"non_interacting/#Number-conserving-non-interacting-hamiltonians","page":"Non interacting systems","title":"Number conserving non-interacting hamiltonians","text":"","category":"section"},{"location":"non_interacting/","page":"Non interacting systems","title":"Non interacting systems","text":"A quadratic fermionic hamiltonian with number conservation can be written as ","category":"page"},{"location":"non_interacting/","page":"Non interacting systems","title":"Non interacting systems","text":"H = Emathbf1 + sum_ij c_i^dagger h_ij  c_j","category":"page"},{"location":"non_interacting/","page":"Non interacting systems","title":"Non interacting systems","text":"The matrix element between two single particle states with modes n and m, i.e. ketn = c_n^dagger ket0, is","category":"page"},{"location":"non_interacting/","page":"Non interacting systems","title":"Non interacting systems","text":" bramHketn = Edelta_nm + h_nm","category":"page"},{"location":"non_interacting/","page":"Non interacting systems","title":"Non interacting systems","text":"If H is hermitian so is h and E is real, but we don't have to restrict to this case here.","category":"page"},{"location":"non_interacting/","page":"Non interacting systems","title":"Non interacting systems","text":"One can manually define the hilbert space using only the single particle states as","category":"page"},{"location":"non_interacting/","page":"Non interacting systems","title":"Non interacting systems","text":"using FermionicHilbertSpaces, LinearAlgebra\nN = 2\nH = hilbert_space(1:N, FermionicHilbertSpaces.SingleParticleState.(1:N))\n@fermions c\nh = rand(ComplexF64, N, N)\nE = rand(ComplexF64)\nop = E * I + sum(c[i]' * h[i, j] * c[j] for i in 1:N, j in 1:N)\nmatrix_representation(op, H) == h + E * I","category":"page"},{"location":"non_interacting/","page":"Non interacting systems","title":"Non interacting systems","text":"Often, h_nm is of interest because diagonalizing it gives information on the quasiparticles in the system.","category":"page"},{"location":"non_interacting/","page":"Non interacting systems","title":"Non interacting systems","text":"tip: Use `single_particle_hilbert_space` instead\nFor convenience, single_particle_hilbert_space can be used define the hilbert space which will give only the single particle states, and will remove the contribution of the identity operator when calling matrix_representation:H = single_particle_hilbert_space(1:N)\nmatrix_representation(op,H) == h # true","category":"page"},{"location":"non_interacting/","page":"Non interacting systems","title":"Non interacting systems","text":"See Free fermions on a 2D grid for an example of how to use this.","category":"page"},{"location":"non_interacting/#Non-interacting-hamiltonians-without-number-conservation","page":"Non interacting systems","title":"Non-interacting hamiltonians without number conservation","text":"","category":"section"},{"location":"non_interacting/","page":"Non interacting systems","title":"Non interacting systems","text":"A general non-interacting hermitian operator respecting super-selection can be written as","category":"page"},{"location":"non_interacting/","page":"Non interacting systems","title":"Non interacting systems","text":"H = Emathbf1 + sum_ij c_i^dagger h_ij  c_j + Delta_ij c_i^dagger c_j^dagger + Delta^dagger_ij c_i c_j","category":"page"},{"location":"non_interacting/","page":"Non interacting systems","title":"Non interacting systems","text":"where h is hermitian, E is real and Delta is antisymmetric. We can do something similar as above by doubling the single particle states with the Nambu states Psi_n = c_n textfor n leq N Psi_n = c_n^dagger textfor n  N, where N is the number of fermions. Then the hamiltonian can be written as","category":"page"},{"location":"non_interacting/","page":"Non interacting systems","title":"Non interacting systems","text":"H = Emathbf1 + sum_ij Psi_i^dagger mathcalH_ij Psi_j","category":"page"},{"location":"non_interacting/","page":"Non interacting systems","title":"Non interacting systems","text":"Since we introduced a redundancy by doubling the single particle states, mathcalH is not unique. One common choice is to use the representation ","category":"page"},{"location":"non_interacting/","page":"Non interacting systems","title":"Non interacting systems","text":"mathcalH = beginpmatrix\nh  Delta \nDelta^dagger  -h^*\nendpmatrix","category":"page"},{"location":"non_interacting/","page":"Non interacting systems","title":"Non interacting systems","text":"We can get this representation manually as follows:","category":"page"},{"location":"non_interacting/","page":"Non interacting systems","title":"Non interacting systems","text":"using FermionicHilbertSpaces, LinearAlgebra\nN = 2\nstates = [FermionicHilbertSpaces.NambuState(n, hole) for (n, hole) in Base.product(1:N, (true, false))]\nH = hilbert_space(1:N, states)\n@fermions c\nh = Hermitian(rand(N, N))\nΔ = rand(N, N) |> m -> m - transpose(m)\nE = rand()\nop = E * I + sum(c[i]' * h[i, j] * c[j] + (Δ[i, j] * c[i]' * c[j]' + Δ'[i, j] * c[i] * c[j]) for i in 1:N, j in 1:N)\nℋ = matrix_representation(op, H) |> FermionicHilbertSpaces.normal_order_to_bdg\nFermionicHilbertSpaces.isbdgmatrix(ℋ)","category":"page"},{"location":"non_interacting/","page":"Non interacting systems","title":"Non interacting systems","text":"The matrix returned by matrix_representation will depend on the ordering of operators in the symbolic operator op. If it is normal ordered (which is the default), one can use FermionicHilbertSpaces.normal_order_to_bdg to convert it to the choice above.","category":"page"},{"location":"non_interacting/","page":"Non interacting systems","title":"Non interacting systems","text":"tip: Use `bdg_hilbert_space` instead\nBy defining the hilbert space using bdg_hilbert_space, one automatically gets the Nambu states and matrix_representation will return a matrix of the form above without the need to manually convert it:Hbdg = bdg_hilbert_space(1:N)\nmatrix_representation(op, Hbdg)\n#= example output\n4×4 SparseArrays.SparseMatrixCSC{Float64, Int64} with 12 stored entries:\n0.449635   0.297613    ⋅         0.18844\n0.297613   0.169731  -0.18844     ⋅\n⋅        -0.18844   -0.449635  -0.297613\n0.18844     ⋅        -0.297613  -0.169731 =#","category":"page"},{"location":"literate_output/kitaev_chain/#Interacting-Kitaev-Chain-Tutorial","page":"Interacting Kitaev chain","title":"Interacting Kitaev Chain Tutorial","text":"","category":"section"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"In this example, we study the interacting Kitaev chain. We show how the Hamiltonian can be constructed symbolically or by using matrix representations of the fermionic operators, and how to restrict the Hilbert space to a subspace of a given parity. We solve for the ground states and characterize the locality of the many-body Majoranas.","category":"page"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"We start by importing the necessary packages.","category":"page"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"using FermionicHilbertSpaces, LinearAlgebra, Plots\nusing Arpack","category":"page"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"Then we define the Hilbert space with N sites and parity conservation.","category":"page"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"N = 12\nH = hilbert_space(1:N, ParityConservation())","category":"page"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"Symbolic fermions can be defined using the @fermions macro,","category":"page"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"@fermions f","category":"page"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"Let's define the interacting Kitaev chain Hamiltonian. It is a function of the fermions f and parameters N, μ, t, Δ, and U, representing the number of sites, chemical potential, hopping amplitude, pairing amplitude, and interaction strength, respectively. Note the use of the Hermitian conjugate hc, which simplifies the expression for the Hamiltonian.","category":"page"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"kitaev_chain(f, N, μ, t, Δ, U) = sum(t * f[i]' * f[i+1] + hc for i in 1:N-1) +\n                                 sum(Δ * f[i] * f[i+1] + hc for i in 1:N-1) +\n                                 sum(U * f[i]' * f[i] * f[i+1]' * f[i+1] for i in 1:N-1) +\n                                 sum(μ[i] * f[i]' * f[i] for i in 1:N)","category":"page"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"Define parameters close to the sweet spot with perfectly localized Majoranas.","category":"page"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"U = 4.0\nt = 1.0\nδΔ = 0.4\nΔ = t + U / 2 - δΔ # slightly detuned from the sweet spot\nμ = fill(-U / 2, N) # edge chemical potential\nμ[2:N-1] .= -U # bulk chemical potential","category":"page"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"We can now construct the Hamiltonian using symbolic fermions for a symbolic representation","category":"page"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"hsym = kitaev_chain(f, N, μ, t, Δ, U)","category":"page"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"To convert the symbolic Hamiltonian to a matrix representation, we can use the matrix_representation function.","category":"page"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"matrix_representation(hsym, H)","category":"page"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"Now, let's diagonalize the system. Since parity is conserved, we can work in the even and odd parity sectors separately. To do this, we can create two new Hilbert spaces for the even and odd sectors","category":"page"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"Heven = hilbert_space(1:N, ParityConservation(1))\nHodd = hilbert_space(1:N, ParityConservation(-1))\nheven = matrix_representation(hsym, Heven)\nhodd = matrix_representation(hsym, Hodd)","category":"page"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"and then diagonalize each sector separately.","category":"page"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"oddeigs = eigs(hodd; nev=1, which=:SR)\neveneigs = eigs(heven; nev=1, which=:SR)\noddvec = oddeigs[2][:, 1] # odd ground state\nevenvec = eveneigs[2][:, 1] # even ground state","category":"page"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"The ground states are almost degenerate, as expected.","category":"page"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"first(oddeigs[1]) - first(eveneigs[1])","category":"page"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"Now, we construct the ground state Majoranas. First, we need to embed the lowest energy odd and even states into the full Hilbert space.","category":"page"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"function extend(v, p)\n    mapreduce(H -> H == first(p) ? v : zeros(size(H, 1)), vcat, last(p))\nend\n\nHsum = (Hodd, Heven)\no = extend(oddvec, Hodd => Hsum) # odd ground state in the full Hilbert space\ne = extend(evenvec, Heven => Hsum) # even ground state in the full Hilbert space","category":"page"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"Then, we can construct the ground state Majorana operators as γ = o * e' + hc γ̃ = 1im * o * e' + hc but that takes a lot of memory for large systems. Let's make a quick struct representing a rank-1 matrix and use that instead.","category":"page"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"struct Rank1Matrix{T} <: AbstractMatrix{T}\n    vec1::Vector{T}\n    vec2::Vector{T}\nend\nBase.getindex(m::Rank1Matrix, i::Int, j::Int) = m.vec1[i] * conj(m.vec2[j])\nBase.size(m::Rank1Matrix) = (length(m.vec1), length(m.vec2))\n\noe = Rank1Matrix(o, e)\nee = Rank1Matrix(e, e)\noo = Rank1Matrix(o, o)","category":"page"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"Now we can compute the reduction of the Majorana operators to each mode.","category":"page"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"Hmodes = [hilbert_space(i:i) for i in 1:N]\neoR = [partial_trace(oe, H => Hmode) for Hmode in Hmodes];\neeR = [partial_trace(ee, H => Hmode) for Hmode in Hmodes];\nooR = [partial_trace(oo, H => Hmode) for Hmode in Hmodes];\nγ_reductions = [norm(svdvals(eoR + hc), 1) for eoR in eoR]\nγ̃_reductions = [norm(svdvals(1im * eoR + hc), 1) for eoR in eoR]\nLD = [norm(svdvals(ooR - eeR), 1) for (ooR, eeR) in zip(ooR, eeR)]","category":"page"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"We can plot the reductions to visualize the localization of the Majorana modes.","category":"page"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"#\nlw = 4\nlegendfontsize = 15\nmarker = true\nmarkerstrokewidth = 2\nplot(xlabel=\"Site\", title=\"Majorana quality measures\"; frame=:box, size=(500, 300), xticks=1:3:N, yscale=:identity, legendfontsize, ylims=(-1e-1, 2), legendposition=:top, labelfontsize=15)\nplot!(1:N, γ_reductions; label=\"‖γₙ‖\", lw, legendfontsize, marker, markerstrokewidth)\nplot!(1:N, γ̃_reductions; label=\"‖γ̃ₙ‖\", lw, legendfontsize, marker, markerstrokewidth)\nplot!(1:N, LD; label=\"‖(iγγ̃)ₙ‖\", lw, legendfontsize, marker, markerstrokewidth)","category":"page"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"","category":"page"},{"location":"literate_output/kitaev_chain/","page":"Interacting Kitaev chain","title":"Interacting Kitaev chain","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#FermionicHilbertSpaces.jl","page":"Home","title":"FermionicHilbertSpaces.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"FermionicHilbertSpaces.jl is a Julia package for defining fermionic Hilbert spaces and operators. The central features are fermionic tensor products and partial traces, which differ from the standard tensor product since fermions anticommute.  [1] ","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg; Pkg.add(url=\"https://github.com/cvsvensson/FermionicHilbertSpaces.jl\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"or by adding a registry to your julia environment and then installing the package","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg; Pkg.Registry.add(RegistrySpec(url = \"https://github.com/williamesamuelson/PackageRegistry\"))\nPkg.add(\"FermionicHilbertSpaces\")","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following example demonstrates how to define a fermionic Hilbert space, create fermionic operators, and construct a simple Hamiltonian:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using FermionicHilbertSpaces, LinearAlgebra\nN = 2 # number of fermions\nspatial_labels = 1:N \ninternal_labels = (:↑,:↓)\nlabels = Base.product(spatial_labels, internal_labels) \nH = hilbert_space(labels) ","category":"page"},{"location":"","page":"Home","title":"Home","text":"c = fermions(H) # fermionic annihilation operators","category":"page"},{"location":"#Define-a-simple-Hamiltonian-from-the-fermionic-operators","page":"Home","title":"Define a simple Hamiltonian from the fermionic operators","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"H_hopping = c[1,:↑]'c[2,:↑] + c[1,:↓]'c[2,:↓] + hc \nH_coulomb = sum(c[n,:↑]'c[n,:↑]c[n,:↓]'c[n,:↓] for n in spatial_labels)\nH_hopping + H_coulomb","category":"page"},{"location":"#Defining-a-symbolic-hamiltonian","page":"Home","title":"Defining a symbolic hamiltonian","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"@fermions f \nmatrix_representation(f[1,:↑]'*f[1,:↑], H)","category":"page"},{"location":"#Tensor-product-and-partial-trace","page":"Home","title":"Tensor product and partial trace","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"H1 = hilbert_space(1:2)\nH2 = hilbert_space(3:4)\nH = tensor_product(H1, H2)\nc1,c2,c = fermions(H1), fermions(H2), fermions(H)\nc1c3 = tensor_product([c1[1], c2[3]], [H1, H2] => H)\nc[1]*c[3] == c1c3","category":"page"},{"location":"","page":"Home","title":"Home","text":"partial_trace(tensor_product([c1[1], I/4], [H1, H2] => H), H => H1) == c1[1] ","category":"page"},{"location":"#Conserved-quantum-numbers","page":"Home","title":"Conserved quantum numbers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"H = hilbert_space([1,2], ParityConservation())","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<a name=\"fermion_information_article\"></a>","category":"page"},{"location":"","page":"Home","title":"Home","text":"[1] Szalay, Szilárd, et al. \"Fermionic systems for quantum information people.\" Journal of Physics A: Mathematical and Theoretical 54.39 (2021): 393001, arXiv:2006.03087","category":"page"},{"location":"literate_output/free_fermions/#Free-fermions-on-a-2D-grid","page":"Free fermions","title":"Free fermions on a 2D grid","text":"","category":"section"},{"location":"literate_output/free_fermions/","page":"Free fermions","title":"Free fermions","text":"For free fermions, one can work in the single particle picture to get a better scaling with the size of the system. FermionicHilbertSpaces.jl contains some features to help with this.","category":"page"},{"location":"literate_output/free_fermions/","page":"Free fermions","title":"Free fermions","text":"using FermionicHilbertSpaces, Plots, LinearAlgebra\nimport FermionicHilbertSpaces: add! # Import add! for efficient Hamiltonian construction\nusing Arpack # For sparse eigenvalue decomposition","category":"page"},{"location":"literate_output/free_fermions/#Define-a-grid","page":"Free fermions","title":"Define a grid","text":"","category":"section"},{"location":"literate_output/free_fermions/","page":"Free fermions","title":"Free fermions","text":"We'll look at a system defined on a disc. Let's define a square grid and then cut out a disc in the middle","category":"page"},{"location":"literate_output/free_fermions/","page":"Free fermions","title":"Free fermions","text":"N = 40\nxs, ys = -N:N, -N:N\nindomain(xy) = norm(xy) < N\nsquare_grid = [indomain(xy) ? xy : missing for xy in Iterators.product(xs, ys)]\ndisc = collect(skipmissing(square_grid))\nshifts = [(1, 0), (0, 1), (-1, 0), (0, -1)]\nneighbours(Nx, Ny) = ((Nx + dx, Ny + dy) for (dx, dy) in shifts if indomain((Nx + dx, Ny + dy)))\nH = single_particle_hilbert_space(disc)","category":"page"},{"location":"literate_output/free_fermions/","page":"Free fermions","title":"Free fermions","text":"For plotting heatmaps later, we need a function to map a vector over the disc to a matrix on the 2d grid","category":"page"},{"location":"literate_output/free_fermions/","page":"Free fermions","title":"Free fermions","text":"function vec_to_square_grid(v::AbstractVector{T}) where T\n    count = 0\n    vals = Vector{Union{T,Missing}}(undef, length(square_grid))\n    for (n, xy) in enumerate(square_grid)\n        if ismissing(xy)\n            vals[n] = missing\n        else\n            count += 1\n            vals[n] = v[count]\n        end\n    end\n    return reshape(vals, size(square_grid))\nend","category":"page"},{"location":"literate_output/free_fermions/#Construct-hamiltonian","page":"Free fermions","title":"Construct hamiltonian","text":"","category":"section"},{"location":"literate_output/free_fermions/","page":"Free fermions","title":"Free fermions","text":"Let's define a quadratic hamiltonian with a spiral chemical potential and hopping","category":"page"},{"location":"literate_output/free_fermions/","page":"Free fermions","title":"Free fermions","text":"function potential(xy)\n    θ = atan(xy...)\n    r = norm(xy) / N\n    5 * cos(2 * (θ - 2 * r))^2 * exp(r)\nend\nhopping(xy1, xy2) = N\n@fermions f","category":"page"},{"location":"literate_output/free_fermions/","page":"Free fermions","title":"Free fermions","text":"Since we are dealing with many fermions, symbolic sums may take a long time. To get better performance, we will use the function add! to update the symbolic hamiltonian in place. For this, it is important to initialize the Hamiltonian with the correct type. We do this by making a simple hamiltonian and then call zero to get an empty hamiltonian of a matching type.","category":"page"},{"location":"literate_output/free_fermions/","page":"Free fermions","title":"Free fermions","text":"ham = zero(1.0 * f[0, 0] * f[1, 1] + 1.0)","category":"page"},{"location":"literate_output/free_fermions/","page":"Free fermions","title":"Free fermions","text":"Now we can build the hamiltonian","category":"page"},{"location":"literate_output/free_fermions/","page":"Free fermions","title":"Free fermions","text":"for xy in disc\n    add!(ham, potential(xy) * f[xy]' * f[xy])\n    for nbr in neighbours(xy...)\n        add!(ham, hopping(nbr, xy) * f[nbr]' * f[xy] + hc)\n    end\nend","category":"page"},{"location":"literate_output/free_fermions/","page":"Free fermions","title":"Free fermions","text":"And get a matrix representation of it on the single particle hilbert space","category":"page"},{"location":"literate_output/free_fermions/","page":"Free fermions","title":"Free fermions","text":"mat = matrix_representation(ham, H)","category":"page"},{"location":"literate_output/free_fermions/#Compute-eigenstates-and-momentum-operators-and-plot-results","page":"Free fermions","title":"Compute eigenstates and momentum operators and plot results","text":"","category":"section"},{"location":"literate_output/free_fermions/","page":"Free fermions","title":"Free fermions","text":"Compute a few eigenvalues/eigenvectors (lowest energy states)","category":"page"},{"location":"literate_output/free_fermions/","page":"Free fermions","title":"Free fermions","text":"vals, vecs = eigs(mat; nev=3^2, which=:SR, v0=map(x -> eltype(mat)(first(x)), disc)[:]);\nnothing #hide","category":"page"},{"location":"literate_output/free_fermions/","page":"Free fermions","title":"Free fermions","text":"Calculate momentum operators px, py and define a function to calculate angular momentum density","category":"page"},{"location":"literate_output/free_fermions/","page":"Free fermions","title":"Free fermions","text":"px = zero(1im * ham)\npy = zero(px)\nfor xy in disc\n    xy .+ (1, 0) in disc && add!(px, 1im * f[xy.+(1, 0)]' * f[xy] + hc)\n    xy .+ (0, 1) in disc && add!(py, 1im * f[xy.+(0, 1)]' * f[xy] + hc)\nend\npxmat = matrix_representation(px, H)\npymat = matrix_representation(py, H);\nfunction angular_momentum(v)\n    px = pxmat * v\n    py = pymat * v\n    vec_to_square_grid(map((px, py, ψ, r) -> imag(conj(ψ) * dot(r, (-py, px))), px, py, v, disc))\nend","category":"page"},{"location":"literate_output/free_fermions/","page":"Free fermions","title":"Free fermions","text":"Plot the number density and angular momentum density of the lowest energy quasiparticles","category":"page"},{"location":"literate_output/free_fermions/","page":"Free fermions","title":"Free fermions","text":"kwargs = (; ticks=0, cbar=false, aspectratio=1, margins=-2Plots.mm, background_color=:black, size=400 .* (1, 1))\np_density = plot([heatmap(xs, ys, vec_to_square_grid(map(abs2, v))) for v in eachcol(vecs)]...; kwargs...)\np_angular = plot([heatmap(xs, ys, angular_momentum(v); c=:twilight, clims=1.5 * N^(-1.5) .* (-1, 1)) for v in eachcol(vecs)]...; kwargs...)\nplot(p_density, p_angular; layout=(1, 2), size=400 .* (2, 1))","category":"page"},{"location":"literate_output/free_fermions/","page":"Free fermions","title":"Free fermions","text":"","category":"page"},{"location":"literate_output/free_fermions/","page":"Free fermions","title":"Free fermions","text":"This page was generated using Literate.jl.","category":"page"},{"location":"docstrings/#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"docstrings/","page":"Functions","title":"Functions","text":"","category":"page"},{"location":"docstrings/#Docstrings","page":"Functions","title":"Docstrings","text":"","category":"section"},{"location":"docstrings/#FermionicHilbertSpaces.FermionConservation","page":"Functions","title":"FermionicHilbertSpaces.FermionConservation","text":"FermionConservation\n\nA symmetry type representing conservation of total fermion number.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#FermionicHilbertSpaces.FockHilbertSpace","page":"Functions","title":"FermionicHilbertSpaces.FockHilbertSpace","text":"FockHilbertSpace\n\nA type representing a Fock Hilbert space with a given set of modes and Fock states.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#FermionicHilbertSpaces.FockNumber","page":"Functions","title":"FermionicHilbertSpaces.FockNumber","text":"FockNumber\n\nA type representing a Fock state as the bitstring of an integer.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#FermionicHilbertSpaces.FockSymmetry","page":"Functions","title":"FermionicHilbertSpaces.FockSymmetry","text":"struct FockSymmetry{IF,FI,QN,QNfunc} <: AbstractSymmetry\n\nFockSymmetry represents a symmetry that is diagonal in fock space, i.e. particle number conservation, parity, spin consvervation.\n\nFields\n\nbasisstates::IF: A vector of Fock numbers, which are integers representing the occupation of each mode.\nstate_indexdict::FI: A dictionary mapping Fock states to indices.\nqntofockstates::Dictionary{QN,Vector{Int}}: A dictionary mapping quantum numbers to Fock states.\nconserved_quantity::QNfunc: A function that computes the conserved quantity from a fock number.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#FermionicHilbertSpaces.HC","page":"Functions","title":"FermionicHilbertSpaces.HC","text":"HC\n\nRepresents the Hermitian conjugate.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#FermionicHilbertSpaces.IndexConservation","page":"Functions","title":"FermionicHilbertSpaces.IndexConservation","text":"IndexConservation\n\nA symmetry type representing conservation of the numbers of modes which contains a specific index or set of indices.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#FermionicHilbertSpaces.JordanWignerOrdering","page":"Functions","title":"FermionicHilbertSpaces.JordanWignerOrdering","text":"JordanWignerOrdering\n\nA type representing the ordering of fermionic modes.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#FermionicHilbertSpaces.NoSymmetry","page":"Functions","title":"FermionicHilbertSpaces.NoSymmetry","text":"NoSymmetry\n\nA symmetry type indicating no symmetry constraints.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#FermionicHilbertSpaces.ParityConservation","page":"Functions","title":"FermionicHilbertSpaces.ParityConservation","text":"ParityConservation\n\nA symmetry type representing conservation of fermion parity.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#FermionicHilbertSpaces.SimpleFockHilbertSpace","page":"Functions","title":"FermionicHilbertSpaces.SimpleFockHilbertSpace","text":"SimpleFockHilbertSpace\n\nA type representing a simple Fock Hilbert space with all fock states included.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#FermionicHilbertSpaces.SymmetricFockHilbertSpace","page":"Functions","title":"FermionicHilbertSpaces.SymmetricFockHilbertSpace","text":"SymmetricFockHilbertSpace\n\nA type representing a Fock Hilbert space with fockstates organized by their quantum number.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#FermionicHilbertSpaces.basisstates-Tuple{SimpleFockHilbertSpace}","page":"Functions","title":"FermionicHilbertSpaces.basisstates","text":"basisstates(H)\n\nReturn an iterator over all basis states for the given Hilbert space H.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#FermionicHilbertSpaces.embedding-Tuple{Any, FermionicHilbertSpaces.AbstractFockHilbertSpace, Any}","page":"Functions","title":"FermionicHilbertSpaces.embedding","text":"embedding(m, Hsub, H; complement = simple_complementary_subsystem(H, Hsub), kwargs...)\n\nCompute the fermionic embedding of a matrix m in the basis Hsub into the basis H.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#FermionicHilbertSpaces.embedding_unitary-Tuple{Any, Any, JordanWignerOrdering}","page":"Functions","title":"FermionicHilbertSpaces.embedding_unitary","text":"embedding_unitary(partition, basisstates, jw)\n\nCompute the unitary matrix that maps between the tensor embedding and the fermionic embedding in the physical subspace. \n# Arguments\n- `partition`: A partition of the labels in `jw` into disjoint sets.\n- `basisstates`: The basis states in the basis\n- `jw`: The Jordan-Wigner ordering.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#FermionicHilbertSpaces.eval_in_basis-Tuple{FermionicHilbertSpaces.FermionSym, Any}","page":"Functions","title":"FermionicHilbertSpaces.eval_in_basis","text":"eval_in_basis(a, f)\n\nEvaluate an expression with fermions in a basis f. \n\nExamples\n\n@fermions a\nf = fermions(hilbert_space(1:2))\nFermionicHilbertSpaces.eval_in_basis(a[1]'*a[2] + hc, f)\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#FermionicHilbertSpaces.extension","page":"Functions","title":"FermionicHilbertSpaces.extension","text":"extension(m, H, Hbar, Hout = tensor_product((H, Hbar)); kwargs...)\n\nExtend an operator or state m from Hilbert space H into a disjoint space Hbar.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#FermionicHilbertSpaces.fermion_sparse_matrix-Tuple{Any, FermionicHilbertSpaces.AbstractFockHilbertSpace}","page":"Functions","title":"FermionicHilbertSpaces.fermion_sparse_matrix","text":"fermion_sparse_matrix(fermion_number, H::AbstractFockHilbertSpace)\n\nConstructs a sparse matrix of size representing a fermionic annihilation operator at bit position fermion_number on the Hilbert space H. \n\n\n\n\n\n","category":"method"},{"location":"docstrings/#FermionicHilbertSpaces.fermion_to_majorana","page":"Functions","title":"FermionicHilbertSpaces.fermion_to_majorana","text":"fermion_to_majorana(expr)\n\nConvert symbolic fermions to symbolic majoranas.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#FermionicHilbertSpaces.fermionic_kron","page":"Functions","title":"FermionicHilbertSpaces.fermionic_kron","text":"fermionic_kron(ms, Hs, H::AbstractHilbertSpace=tensor_product(Hs))\n\nCompute the fermionic tensor product of matrices or vectors in ms with respect to the spaces Hs, respectively. Return a matrix in the space H, which defaults to the tensor_product product of Hs.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#FermionicHilbertSpaces.fermions-Tuple{FermionicHilbertSpaces.AbstractFockHilbertSpace}","page":"Functions","title":"FermionicHilbertSpaces.fermions","text":"fermions(H)\n\nReturn a dictionary of fermionic annihilation operators for the Hilbert space H.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#FermionicHilbertSpaces.fixed_particle_number_fockstates-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T","page":"Functions","title":"FermionicHilbertSpaces.fixed_particle_number_fockstates","text":"fixed_particle_number_fockstates(M, n)\n\nGenerate a list of Fock states with n occupied fermions in a system with M different fermions.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#FermionicHilbertSpaces.focksymmetry-Tuple{Any, Any}","page":"Functions","title":"FermionicHilbertSpaces.focksymmetry","text":"focksymmetry(basisstates, qn)\n\nConstructs a FockSymmetry object that represents the symmetry of a many-body system. \n\nArguments\n\nbasisstates: The basisstates to iterate over\nqn: A function that takes an integer representing a fock state and returns corresponding quantum number.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#FermionicHilbertSpaces.hilbert_space-Tuple{Any}","page":"Functions","title":"FermionicHilbertSpaces.hilbert_space","text":"hilbert_space(labels[, symmetry, basisstates])\n\nConstruct a Hilbert space from a set of labels, with optional symmetry and Fock number specification.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#FermionicHilbertSpaces.jwstring-Tuple{Any, Any}","page":"Functions","title":"FermionicHilbertSpaces.jwstring","text":"jwstring(site, focknbr)\n\nParity of the number of fermions to the right of site.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#FermionicHilbertSpaces.majorana_to_fermion","page":"Functions","title":"FermionicHilbertSpaces.majorana_to_fermion","text":"majorana_to_fermion(expr)\n\nConvert symbolic majoranas to symbolic fermions.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#FermionicHilbertSpaces.majoranas","page":"Functions","title":"FermionicHilbertSpaces.majoranas","text":"majoranas(H)\n\nReturn a dictionary of Majorana operators for the Hilbert space H.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#FermionicHilbertSpaces.numberoperator-Tuple{FermionicHilbertSpaces.AbstractFockHilbertSpace}","page":"Functions","title":"FermionicHilbertSpaces.numberoperator","text":"numberoperator(H)\n\nReturn the number operator for the Hilbert space H.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#FermionicHilbertSpaces.parityoperator-Tuple{FermionicHilbertSpaces.AbstractFockHilbertSpace}","page":"Functions","title":"FermionicHilbertSpaces.parityoperator","text":"parityoperator(H)\n\nReturn the fermionic parity operator for the Hilbert space H.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#FermionicHilbertSpaces.partial_trace!-Tuple{Any, AbstractMatrix, FermionicHilbertSpaces.AbstractHilbertSpace, FermionicHilbertSpaces.AbstractHilbertSpace, Bool, Any}","page":"Functions","title":"FermionicHilbertSpaces.partial_trace!","text":"partial_trace!(mout, m::AbstractMatrix, H::AbstractHilbertSpace, Hsub::AbstractHilbertSpace, phase_factors, complement)\n\nCompute the fermionic partial trace of a matrix m in basis H, leaving only the subsystems specified by labels. The result is stored in mout, and Hsub determines the ordering of the basis states.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#FermionicHilbertSpaces.partial_trace-Union{Tuple{T}, Tuple{AbstractMatrix{T}, FermionicHilbertSpaces.AbstractHilbertSpace, FermionicHilbertSpaces.AbstractHilbertSpace}} where T","page":"Functions","title":"FermionicHilbertSpaces.partial_trace","text":"partial_trace(m::AbstractMatrix,  Hfull::AbstractHilbertSpace, Hsub::AbstractHilbertSpace; phase_factors = true, complement)\n\nCompute the partial trace of a matrix m, leaving the subsystem defined by the basis Hsub.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#FermionicHilbertSpaces.removefermion-Tuple{Any, FockNumber}","page":"Functions","title":"FermionicHilbertSpaces.removefermion","text":"removefermion(digitposition, f::FockNumber)\n\nReturn (newfocknbr, fermionstatistics) where newfocknbr is the state obtained by removing a fermion at digitposition from f and fermionstatistics is the phase from the Jordan-Wigner string, or 0 if the operation is not allowed.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#FermionicHilbertSpaces.subregion-Tuple{Any, SimpleFockHilbertSpace}","page":"Functions","title":"FermionicHilbertSpaces.subregion","text":"subregion(modes, H::AbstractHilbertSpace)\n\nReturn a subregion of the Hilbert space H that is spanned by the modes in modes. Only substates in H are included.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#FermionicHilbertSpaces.tensor_product-Tuple{AbstractVector{<:FermionicHilbertSpaces.AbstractHilbertSpace}}","page":"Functions","title":"FermionicHilbertSpaces.tensor_product","text":"tensor_product(Hs)\n\nCompute the tensorproduct product hilbert spaces Hs. The symmetry of the resulting basis is computed by promotesymmetry.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#FermionicHilbertSpaces.tensor_product-Tuple{Union{Tuple, AbstractVector}, Any, FermionicHilbertSpaces.AbstractHilbertSpace}","page":"Functions","title":"FermionicHilbertSpaces.tensor_product","text":"tensor_product(ms, Hs, H::AbstractHilbertSpace; kwargs...)\n\nCompute the ordered product of the fermionic embeddings of the matrices ms in the spaces Hs into the space H. kwargs can be passed a bool phase_factors and a hilbert space complement.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#FermionicHilbertSpaces.togglefermions-Union{Tuple{I}, Tuple{Any, Any, FockNumber{I}}} where I","page":"Functions","title":"FermionicHilbertSpaces.togglefermions","text":"togglefermions(digitpositions, daggers, f::FockNumber)\n\nReturn (newfocknbr, fermionstatistics) where newfocknbr is the state obtained by toggling fermions at digitpositions with daggers in the Fock state f, and fermionstatistics is the phase from the Jordan-Wigner string. If the operation puts two fermions one the same site, the resulting state is undefined.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#FermionicHilbertSpaces.tryadd!-Tuple{FermionicHilbertSpaces.FermionAdd, Any}","page":"Functions","title":"FermionicHilbertSpaces.tryadd!","text":"tryadd!(c::FermionAdd, term)\n\nThis function tries to add term to c in place. If it fails, it catches the error and returns the out of place sum.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#FermionicHilbertSpaces.@fermions-Tuple","page":"Functions","title":"FermionicHilbertSpaces.@fermions","text":"@fermions a b ...\n\nCreate one or more fermion species with the given names. Indexing into fermions species gives a concrete fermion. Fermions in one @fermions block anticommute with each other,  and commute with fermions in other @fermions blocks.\n\nExamples:\n\n@fermions a b creates two species of fermions that anticommute:\na[1]' * a[1] + a[1] * a[1]' == 1\na[1]' * b[1] + b[1] * a[1]' == 0\n@fermions a; @fermions b creates two species of fermions that commute with each other:\na[1]' * a[1] + a[1] * a[1]' == 1\na[1] * b[1] - b[1] * a[1] == 0\n\nSee also @majoranas, FermionicHilbertSpaces.eval_in_basis.\n\n\n\n\n\n","category":"macro"},{"location":"docstrings/#FermionicHilbertSpaces.@majoranas-Tuple","page":"Functions","title":"FermionicHilbertSpaces.@majoranas","text":"@majoranas a b ...\n\nCreate one or more Majorana species with the given names. Indexing into Majorana species gives a concrete Majorana. Majoranas in one @majoranas block anticommute with each other, and commute with Majoranas in other @majoranas blocks.\n\nExamples:\n\n@majoranas a b creates two species of Majoranas that anticommute:\na[1] * a[1] + a[1] * a[1] == 1\na[1] * b[1] + b[1] * a[1] == 0\n@majoranas a; @majoranas b creates two species of Majoranas that commute with each other:\na[1] * a[1] + a[1] * a[1] == 1\na[1] * b[1] - b[1] * a[1] == 0\n\nSee also @fermions, FermionicHilbertSpaces.eval_in_basis.\n\n\n\n\n\n","category":"macro"}]
}
