var documenterSearchIndex = {"docs":
[{"location":"conservation/#Conserved-quantum-numbers","page":"Conserved quantities","title":"Conserved quantum numbers","text":"The basis states of a Hilbert space can be organized into sectors with different quantum numbers. Only quantum numbers which are diagonal in the fock state basis are supported. \n\nUse hilbert_space(labels, qn), where qn can be e.g.\n\nParityConservation(): Puts all states with odd parity first, then all states with even parity.\nParityConservation(p::Int): Only contains states with parity p (-1 for odd and 1 for even).\nnumber_conservation(): Sorts basis states by the number of fermions.\nnumber_conservation(sectors::Union{Int,Vector{Int}}): Only contains states with the number(s) in the list sectors.\nnumber_conservation(sectors, weight_function): 'weight_function' is a function that takes a label and returns an integer weight that represents the contribution of that fermion to the total number. The returned states will have total weighted number of fermions contained in sectors.\nnumber_conservation(weight_function): As above, but allowing all sectors.\nProducts of the above quantum numbers, which sorts states according to each factor in the product.\n\nUsing number_conservation with small sectors avoids the exponentially large Hilbert space.","category":"section"},{"location":"conservation/#Spin","page":"Conserved quantities","title":"Spin","text":"This package does not know anything about spin, but one can treat spin just as an extra label as follows:\n\nusing FermionicHilbertSpaces\nlabels = Base.product(1:4, (:↑,:↓))\nH = hilbert_space(labels)\n\nIf spin is conserved, one can use \n\nH = hilbert_space(labels, number_conservation(label -> :↑ in label) * number_conservation(label -> :↓ in label))\n\nto sort states according to the number of fermions with spin up and down. However, this package can't help to sort states into sectors with different total angular momentum, because that requires taking superpositions of different fock states.\n\nTo pick out the sector with 2 fermions with spin up and 0 fermions with spin down, one can extract it from the hilbert space defined above using sector, or construct it directly\n\nFermionicHilbertSpaces.sector((2,0), H)\nhilbert_space(labels, number_conservation(2, label -> :↑ in label) * number_conservation(0, label -> :↓ in label))","category":"section"},{"location":"conservation/#Small-subspaces-in-large-systems","page":"Conserved quantities","title":"Small subspaces in large systems","text":"For N fermions, the full hilbert space is exponentially large in N. However, due to conservation laws, we may be interested in only a small subspace. If you use a quantum number which consists of only products of number conservations, this package attempts to find the subspaces without enumerating the full hilbert space.\n\nAs an example, consider the Hubbard model on N sites \n\nH = -t sum_isigma (c_isigma^dagger c_i+1sigma + mathrmhc) + U sum_i n_i n_i\n\nwhich conserves the number of spin up and spin down fermions separately. Let's define a function to get the hamiltonian with symbolic fermions \n\nusing FermionicHilbertSpaces\nfunction hubbard_hamiltonian(N, t, U)\n    @fermions c\n    spins = (:↑,:↓)\n    sum(-t * c[i,σ]' * c[i+1,σ] + hc for σ in spins for i in 1:N-1) + sum(U * c[i,:↑]'c[i,:↑] * c[i,:↓]'c[i,:↓] for i in 1:N)\nend\n\nLet's find the matrix representation of the hamiltonian in the sector with N_up spin up fermions and N_down spin down fermions. To find this subspace we do\n\nN = 20\nlabels = Base.product(1:N, (:↑,:↓))\nN_up = 2\nN_down = 1\nqn_spin = number_conservation(N_up, label -> :↑ in label) * number_conservation(N_down, label -> :↓ in label)\nH = hilbert_space(labels, qn_spin)\n\nThe full hilbert space is of size 4^20 ≈ 10^12, but the sector with 2 spin up and 1 spin down fermion is only of size 3800 and is generated without constructing the full hilbert space. Finally, we can get the matrix representation of the hamiltonian in this sector as\n\nsymham = hubbard_hamiltonian(N, 1.0, 4.0)\nham = matrix_representation(symham, H)","category":"section"},{"location":"conservation/#No-double-occupation","page":"Conserved quantities","title":"No double occupation","text":"When the onsite Coulomb interaction is very strong, there is a large energy penalty for double occupation of a site. In that case, we can restrict the Hilbert space to not allow double occupation of any site. Consider the site k, which has two labels (k, :↑) and (k, :↓). We can use number_conservation(0:1, label -> label[1] == k) which says that the sum of occupation numbers of all labels where the first element of the label equals k is contained in the set 0:1. To impose this for all sites, we take the product over all sites.\n\nqn_no_double_occ = prod(number_conservation(0:1, label -> label[1] == k) for k in 1:N)\nqn = qn_spin * qn_no_double_occ\nH_ndo = hilbert_space(labels, qn)\n\nThis quantum number is a product of number conservations, so the sector is constructed without enumerating the full Hilbert space.\n\nThe matrix representation of the hamiltonian in this sector can be constructed as before, but now we need to specify projection = true as the symbolic hamiltonian maps states in the subspace to states outside the subspace. The keyword projection = true says to ignore those terms.\n\nsymham = hubbard_hamiltonian(N, 1, 0)\nham_ndo = matrix_representation(symham, H_ndo; projection = true)","category":"section"},{"location":"conservation/#More-advanced-use-of-conserved-quantities:-Fractionalized-hilbert-space","page":"Conserved quantities","title":"More advanced use of conserved quantities: Fractionalized hilbert space","text":"The t-J_z model is\n\nH = -t sum_isigma (c_isigma^dagger c_i+1sigma + mathrmhc) + J_z sum_i S^z_i S^z_i+1\n\nwhere S^z_i = n_i - n_i and double occupation is forbidden. This model features a fractionalized hilbert space where the Hilbert space splits into exponentially many dynamically disconnected sectors, see [1910.06341]. We implement the hamiltonian as\n\nfunction tjz(N,t,Jz)\n    @fermions c\n    spins = (:↑,:↓)\n    Sz(i) = c[i,:↑]'c[i,:↑] - c[i,:↓]'c[i,:↓]\n    -t*sum(c[i,σ]'c[i+1,σ] + hc for σ in spins for i in 1:N-1) + Jz*sum(Sz(i)Sz(i+1) for i in 1:N-1)\nend\n\nTo construct the hilbert space for this model, we first use the same conservation as above to restrict to no double occupation and conserve spin. This gives a conserved quantum numbers which is a product of number conservations and so it is efficient in generating states.\n\nN = 12\nN_up = 4\nN_down = 1\nlabels = Base.product(1:N, (:↑,:↓))\nqn_spin = number_conservation(N_up, label -> :↑ in label) * number_conservation(N_down, label -> :↓ in label)\nqn = qn_spin * qn_no_double_occ\nH = hilbert_space(labels, qn)\nsymham = tjz(N, 1, 1/4)\nham = matrix_representation(symham, H; projection = true)\n\nThis space fragments into more sectors, which are labelled by the order of occupied spins. By defining a function that maps states to the spin order, we can split the hilbert space into those fragments. The function can be defined as\n\nfunction spin_order(state, H)\n    N = length(keys(H)) ÷ 2\n    occupations = map(1:N) do n\n        if FermionicHilbertSpaces.occupation(state, (n, :↑), H)\n            :↑\n        elseif FermionicHilbertSpaces.occupation(state, (n, :↓), H)\n            :↓\n        else\n            :hole\n        end\n    end\n    filter(x -> x != :hole, occupations)\nend\n\nWe can then construct the fractionalized hilbert space as\n\nqnfrac = Base.Fix2(spin_order, H)\nHfrac = FermionicHilbertSpaces.symmetrize(H, qnfrac)\nHfrac.symmetry.qntofockstates\n\nThis splits the space of dimension 3960 into 5 fragments each of size 792. \n\nLet's find the half-chain entanglement entropy of the ground state in each sector. We can iterate over sectors by calling sectors(H), and we can use subregion to find the hilbert space of a subsystem. \n\nusing Arpack, LinearAlgebra\nusing FermionicHilbertSpaces: sectors\nleft_labels = Base.product(1:(N÷2), (:↑,:↓))\nentropy(ρ) = sum(-λ * log(λ) for λ in eigvals(Hermitian(ρ)) if λ > 1e-12)\nmap(sectors(Hfrac)) do Hsec\n    ham = matrix_representation(symham, Hsec; projection = true)\n    vals, vecs = eigs(ham, nev = 1)\n    Hleft = subregion(left_labels, Hsec)\n    rholeft = partial_trace(vecs[:,1]*vecs[:,1]', Hsec => Hleft)\n    entropy(rholeft)\nend","category":"section"},{"location":"misc/#Misc","page":"Misc","title":"Misc","text":"","category":"section"},{"location":"misc/#Subregion","page":"Misc","title":"Subregion","text":"The function subregion can be used to extract the Hilbert space of a subregion.\n\nusing FermionicHilbertSpaces\nH = hilbert_space(1:4)\nHsub = subregion(1:2, H)\n\nWhen the Hilbert space has a restricted set of fock states, the Hilbert space of the subregion will only include fock states compatible with this restriction. In the example below, the total number of particles 1, and the subregion will have three possible states: (1,0), (0,1), and (0,0).\n\nH = hilbert_space(1:4, number_conservation(1))\nHsub = subregion(1:2, H)\nbasisstates(Hsub)\n\n","category":"section"},{"location":"non_interacting/#Non-interacting-hamiltonians","page":"Non interacting systems","title":"Non-interacting hamiltonians","text":"","category":"section"},{"location":"non_interacting/#Number-conserving-non-interacting-hamiltonians","page":"Non interacting systems","title":"Number conserving non-interacting hamiltonians","text":"A quadratic fermionic hamiltonian with number conservation can be written as \n\nH = Emathbf1 + sum_ij c_i^dagger h_ij  c_j\n\nThe matrix element between two single particle states with modes n and m, i.e. ketn = c_n^dagger ket0, is\n\n bramHketn = Edelta_nm + h_nm\n\nIf H is hermitian so is h and E is real, but we don't have to restrict to this case here.\n\nOne can manually define the hilbert space using only the single particle states as\n\nusing FermionicHilbertSpaces, LinearAlgebra\nN = 2\nH = hilbert_space(1:N, FermionicHilbertSpaces.SingleParticleState.(1:N))\n@fermions c\nh = rand(ComplexF64, N, N)\nE = rand(ComplexF64)\nop = E * I + sum(c[i]' * h[i, j] * c[j] for i in 1:N, j in 1:N)\nmatrix_representation(op, H) == h + E * I\n\nOften, h_nm is of interest because diagonalizing it gives information on the quasiparticles in the system.\n\ntip: Use `single_particle_hilbert_space` instead\nFor convenience, single_particle_hilbert_space can be used define the hilbert space which will give only the single particle states, and will remove the contribution of the identity operator when calling matrix_representation:H = single_particle_hilbert_space(1:N)\nmatrix_representation(op,H) == h # true\n\nSee Free fermions on a 2D grid for an example of how to use this.","category":"section"},{"location":"non_interacting/#Non-interacting-hamiltonians-without-number-conservation","page":"Non interacting systems","title":"Non-interacting hamiltonians without number conservation","text":"A general non-interacting hermitian operator respecting super-selection can be written as\n\nH = Emathbf1 + sum_ij c_i^dagger h_ij  c_j + Delta_ij c_i^dagger c_j^dagger + Delta^dagger_ij c_i c_j\n\nwhere h is hermitian, E is real and Delta is antisymmetric. We can do something similar as above by doubling the single particle states with the Nambu states Psi_n = c_n textfor n leq N Psi_n = c_n^dagger textfor n  N, where N is the number of fermions. Then the hamiltonian can be written as\n\nH = Emathbf1 + sum_ij Psi_i^dagger mathcalH_ij Psi_j\n\nSince we introduced a redundancy by doubling the single particle states, mathcalH is not unique. One common choice is to use the representation \n\nmathcalH = beginpmatrix\nh  Delta \nDelta^dagger  -h^*\nendpmatrix\n\nWe can get this representation manually as follows:\n\nusing FermionicHilbertSpaces, LinearAlgebra\nN = 2\nstates = [FermionicHilbertSpaces.NambuState(n, hole) for (n, hole) in Base.product(1:N, (true, false))]\nH = hilbert_space(1:N, states)\n@fermions c\nh = Hermitian(rand(N, N))\nΔ = rand(N, N) |> m -> m - transpose(m)\nE = rand()\nop = E * I + sum(c[i]' * h[i, j] * c[j] + (Δ[i, j] * c[i]' * c[j]' + Δ'[i, j] * c[i] * c[j]) for i in 1:N, j in 1:N)\nℋ = matrix_representation(op, H) |> FermionicHilbertSpaces.normal_order_to_bdg\nFermionicHilbertSpaces.isbdgmatrix(ℋ)\n\nThe matrix returned by matrix_representation will depend on the ordering of operators in the symbolic operator op. If it is normal ordered (which is the default), one can use FermionicHilbertSpaces.normal_order_to_bdg to convert it to the choice above.\n\ntip: Use `bdg_hilbert_space` instead\nBy defining the hilbert space using bdg_hilbert_space, one automatically gets the Nambu states and matrix_representation will return a matrix of the form above without the need to manually convert it:Hbdg = bdg_hilbert_space(1:N)\nmatrix_representation(op, Hbdg)\n#= example output\n4×4 SparseArrays.SparseMatrixCSC{Float64, Int64} with 12 stored entries:\n0.449635   0.297613    ⋅         0.18844\n0.297613   0.169731  -0.18844     ⋅\n⋅        -0.18844   -0.449635  -0.297613\n0.18844     ⋅        -0.297613  -0.169731 =#","category":"section"},{"location":"literate_output/kitaev_chain/#Interacting-Kitaev-Chain-Tutorial","page":"Interacting Kitaev chain","title":"Interacting Kitaev Chain Tutorial","text":"In this example, we study the interacting Kitaev chain. We show how the Hamiltonian can be constructed symbolically or by using matrix representations of the fermionic operators, and how to restrict the Hilbert space to a subspace of a given parity. We solve for the ground states and characterize the locality of the many-body Majoranas.\n\nWe start by importing the necessary packages.\n\nusing FermionicHilbertSpaces, LinearAlgebra, Plots\nusing Arpack\n\nThen we define the Hilbert space with N sites and parity conservation.\n\nN = 12\nH = hilbert_space(1:N, ParityConservation())\n\nSymbolic fermions can be defined using the @fermions macro,\n\n@fermions f\n\nLet's define the interacting Kitaev chain Hamiltonian. It is a function of the fermions f and parameters N, μ, t, Δ, and U, representing the number of sites, chemical potential, hopping amplitude, pairing amplitude, and interaction strength, respectively. Note the use of the Hermitian conjugate hc, which simplifies the expression for the Hamiltonian.\n\nkitaev_chain(f, N, μ, t, Δ, U) = sum(t * f[i]' * f[i+1] + hc for i in 1:N-1) +\n                                 sum(Δ * f[i] * f[i+1] + hc for i in 1:N-1) +\n                                 sum(U * f[i]' * f[i] * f[i+1]' * f[i+1] for i in 1:N-1) +\n                                 sum(μ[i] * f[i]' * f[i] for i in 1:N)\n\nDefine parameters close to the sweet spot with perfectly localized Majoranas.\n\nU = 4.0\nt = 1.0\nδΔ = 0.4\nΔ = t + U / 2 - δΔ # slightly detuned from the sweet spot\nμ = fill(-U / 2, N) # edge chemical potential\nμ[2:N-1] .= -U # bulk chemical potential\n\nWe can now construct the Hamiltonian using symbolic fermions for a symbolic representation\n\nhsym = kitaev_chain(f, N, μ, t, Δ, U)\n\nTo convert the symbolic Hamiltonian to a matrix representation, we can use the matrix_representation function.\n\nmatrix_representation(hsym, H)\n\nNow, let's diagonalize the system. Since parity is conserved, we can work in the even and odd parity sectors separately.\n\nimport FermionicHilbertSpaces: indices, sector, quantumnumbers\n(Eo, o), (Ee, e) = map(quantumnumbers(H)) do parity\n    Hsec = sector(parity, H)\n    ham = matrix_representation(hsym, Hsec)\n    vals, vecs = eigs(ham; nev=1, which=:SR)\n    inds = indices(Hsec, H)\n    ground_state = zeros(eltype(vecs), dim(H))\n    ground_state[inds] = vecs[:, 1]\n    (; energy=first(vals), ground_state)\nend\n\nThe ground states are almost degenerate, as expected. Then, we can construct the ground state Majorana operators as γ = o * e' + hc and γ̃ = 1im * o * e' + hc but that takes a lot of memory for large systems. We can use LowRankMatrices.jl to avoid this\n\nusing LowRankMatrices\nγ = LowRankMatrix(o, e) + hc\nγ̃ = 1im * LowRankMatrix(o, e) + hc\nδρ = LowRankMatrix(o, o) - LowRankMatrix(e, e)\n\nNow we can compute the reduction of the Majorana operators to each mode.\n\nHmodes = [hilbert_space(i:i) for i in 1:N]\nγR = [partial_trace(γ, H => Hmode) for Hmode in Hmodes];\nγ̃R = [partial_trace(γ̃, H => Hmode) for Hmode in Hmodes];\nδρR = [partial_trace(δρ, H => Hmode) for Hmode in Hmodes];\nγ_reductions = [norm(svdvals(γ), 1) for γ in γR]\nγ̃_reductions = [norm(svdvals(γ̃), 1) for γ̃ in γ̃R]\nLD = [norm(svdvals(δρ), 1) for δρ in δρR]\n\nWe can plot the reductions to visualize the localization of the Majorana modes.\n\n#\nlw = 4\nlegendfontsize = 15\nmarker = true\nmarkerstrokewidth = 2\nplot(xlabel=\"Site\", title=\"Majorana quality measures\"; frame=:box, size=(500, 300), xticks=1:3:N, yscale=:identity, legendfontsize, ylims=(-1e-1, 2), legendposition=:top, labelfontsize=15)\nplot!(1:N, γ_reductions; label=\"‖γₙ‖\", lw, legendfontsize, marker, markerstrokewidth)\nplot!(1:N, γ̃_reductions; label=\"‖γ̃ₙ‖\", lw, legendfontsize, marker, markerstrokewidth)\nplot!(1:N, LD; label=\"‖(iγγ̃)ₙ‖\", lw, legendfontsize, marker, markerstrokewidth)\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"#FermionicHilbertSpaces.jl","page":"Home","title":"FermionicHilbertSpaces.jl","text":"FermionicHilbertSpaces.jl is a Julia package for defining fermionic Hilbert spaces and operators. The central features are fermionic tensor products and partial traces, which differ from the standard tensor product since fermions anticommute.  [1] ","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"The following example demonstrates how to define a fermionic Hilbert space and construct a simple Hamiltonian.\n\nusing FermionicHilbertSpaces, LinearAlgebra\nN = 2 # number of fermions\nspatial_labels = 1:N \ninternal_labels = (:↑,:↓)\nlabels = Base.product(spatial_labels, internal_labels) \nH = hilbert_space(labels) \n\nWe now have a Hilbert space representing 2N fermions. To construct operators on this space we first call @fermions c which makes c represent symbolic fermions. Indexing into c returns an operator representing an annihilation operator e.g. c[1,:↑]. The creation operator is given by the adjoint c[1,:↑]'. These can be multiplied and added together. Here is a simple Hamiltonian with hopping and Coulomb interaction.\n\n@fermions c\nhopping = c[1,:↑]'c[2,:↑] + c[1,:↓]'c[2,:↓] + hc \ncoulomb = sum(c[n,:↑]'c[n,:↑]c[n,:↓]'c[n,:↓] for n in spatial_labels)\nham = hopping + coulomb\n\nTo get the matrix representation of this operator on the Hilbert space, do\n\nmat = matrix_representation(ham, H)","category":"section"},{"location":"#Tensor-product-and-partial-trace","page":"Home","title":"Tensor product and partial trace","text":"This package also includes functionality for combining Hilbert spaces and operators on them, and taking partial traces, in a way that is consistent with fermionic anticommutation relations. \n\nH1 = hilbert_space(1:2)\nH2 = hilbert_space(3:4)\nH = tensor_product(H1, H2)\nc1 = matrix_representation(c[1], H1)\nc3 = matrix_representation(c[3], H2)\nc1c3 = matrix_representation(c[1] * c[3], H)\n# Use embed to embed operators into a larger space\nembed(c1, H1 => H) * embed(c3, H2 => H) ≈ c1c3 #true \n# Or call tensor_product to combine operators from different spaces\ntensor_product((c1, c3), (H1, H2) => H) ≈ c1c3 \n\nLet's partial trace to sites 1 and 3. Let's get a Hilbert space for those sites by using the function subregion, and then we can partial trace to that space with partial_trace.\n\nHsub = subregion([1,3], H)\ndim(Hsub) / dim(H) * partial_trace(c1c3, H => Hsub) ≈ matrix_representation(c[1] * c[3], Hsub)","category":"section"},{"location":"#Conserved-quantum-numbers","page":"Home","title":"Conserved quantum numbers","text":"This package also includes some functionality for working with conserved quantum numbers. If we have for example number conservation, we might want to get a block structure of the hamiltonian. Here's how one can do that:\n\nH = hilbert_space(labels, number_conservation())\nmatrix_representation(ham, H)\n\nThis has a block structure corresponding to the different sectors. To only look at some sectors, for example the sectors with 0, 2 and 4 particles, use\n\nH = hilbert_space(labels, number_conservation([0, 2, 4]))\nmatrix_representation(ham, H)\n\nThose sectors have even fermionic parity, which can alternatively be specified with ParityConservation.\n\nH = hilbert_space(labels, ParityConservation(1))\nmatrix_representation(ham, H)","category":"section"},{"location":"#References","page":"Home","title":"References","text":"<a name=\"fermion_information_article\"></a>\n\n[1] Szalay, Szilárd, et al. \"Fermionic systems for quantum information people.\" Journal of Physics A: Mathematical and Theoretical 54.39 (2021): 393001, arXiv:2006.03087","category":"section"},{"location":"literate_output/free_fermions/#Free-fermions-on-a-2D-grid","page":"Free fermions","title":"Free fermions on a 2D grid","text":"For free fermions, one can work in the single particle picture to get a better scaling with the size of the system. FermionicHilbertSpaces.jl contains some features to help with this.\n\nusing FermionicHilbertSpaces, Plots, LinearAlgebra\nimport FermionicHilbertSpaces: add!! # Import add!! for efficient Hamiltonian construction\nusing Arpack # For sparse eigenvalue decomposition","category":"section"},{"location":"literate_output/free_fermions/#Define-a-grid","page":"Free fermions","title":"Define a grid","text":"We'll look at a system defined on a disc. Let's define a square grid and then cut out a disc in the middle\n\nN = 40\nxs, ys = -N:N, -N:N\nindomain(xy) = norm(xy) < N\nsquare_grid = [indomain(xy) ? xy : missing for xy in Iterators.product(xs, ys)]\ndisc = collect(skipmissing(square_grid))\nshifts = [(1, 0), (0, 1), (-1, 0), (0, -1)]\nneighbours(Nx, Ny) = ((Nx + dx, Ny + dy) for (dx, dy) in shifts if indomain((Nx + dx, Ny + dy)))\nH = single_particle_hilbert_space(disc)\n\nFor plotting heatmaps later, we need a function to map a vector over the disc to a matrix on the 2d grid\n\nfunction vec_to_square_grid(v::AbstractVector{T}) where T\n    count = 0\n    vals = Vector{Union{T,Missing}}(undef, length(square_grid))\n    for (n, xy) in enumerate(square_grid)\n        if ismissing(xy)\n            vals[n] = missing\n        else\n            count += 1\n            vals[n] = v[count]\n        end\n    end\n    return reshape(vals, size(square_grid))\nend","category":"section"},{"location":"literate_output/free_fermions/#Construct-hamiltonian","page":"Free fermions","title":"Construct hamiltonian","text":"Let's define a quadratic hamiltonian with a spiral chemical potential and hopping\n\nfunction potential(xy)\n    θ = atan(xy...)\n    r = norm(xy) / N\n    5 * cos(2 * (θ - 2 * r))^2 * exp(r)\nend\nhopping(xy1, xy2) = N\n@fermions f\n\nSince we are dealing with many fermions, symbolic sums may take a long time. To get better performance, we will use the function add!! to update the symbolic hamiltonian in place. For this, it is important to initialize the Hamiltonian with the correct type. We do this by making a simple hamiltonian and then call zero to get an empty hamiltonian of a matching type.\n\nham = zero(1.0 * f[0, 0] * f[1, 1] + 1.0)\n\nNow we can build the hamiltonian\n\nfor xy in disc\n    add!!(ham, potential(xy) * f[xy]' * f[xy])\n    for nbr in neighbours(xy...)\n        add!!(ham, hopping(nbr, xy) * f[nbr]' * f[xy] + hc)\n    end\nend\n\nAnd get a matrix representation of it on the single particle hilbert space\n\nmat = matrix_representation(ham, H)","category":"section"},{"location":"literate_output/free_fermions/#Compute-eigenstates-and-momentum-operators-and-plot-results","page":"Free fermions","title":"Compute eigenstates and momentum operators and plot results","text":"Compute a few eigenvalues/eigenvectors (lowest energy states)\n\nvals, vecs = eigs(mat; nev=3^2, which=:SR, v0=map(x -> eltype(mat)(first(x)), disc)[:]);\nnothing #hide\n\nCalculate momentum operators px, py and define a function to calculate angular momentum density\n\npx = zero(1im * ham)\npy = zero(px)\nfor xy in disc\n    xy .+ (1, 0) in disc && add!!(px, 1im * f[xy.+(1, 0)]' * f[xy] + hc)\n    xy .+ (0, 1) in disc && add!!(py, 1im * f[xy.+(0, 1)]' * f[xy] + hc)\nend\npxmat = matrix_representation(px, H)\npymat = matrix_representation(py, H);\nfunction angular_momentum(v)\n    px = pxmat * v\n    py = pymat * v\n    vec_to_square_grid(map((px, py, ψ, r) -> imag(conj(ψ) * dot(r, (-py, px))), px, py, v, disc))\nend\n\nPlot the number density and angular momentum density of the lowest energy quasiparticles\n\nkwargs = (; ticks=0, cbar=false, aspectratio=1, margins=-2Plots.mm, background_color=:black, size=400 .* (1, 1))\np_density = plot([heatmap(xs, ys, vec_to_square_grid(map(abs2, v))) for v in eachcol(vecs)]...; kwargs...)\np_angular = plot([heatmap(xs, ys, angular_momentum(v); c=:twilight, clims=1.5 * N^(-1.5) .* (-1, 1)) for v in eachcol(vecs)]...; kwargs...)\nplot(p_density, p_angular; layout=(1, 2), size=400 .* (2, 1))\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"docstrings/#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"docstrings/#Docstrings","page":"Functions","title":"Docstrings","text":"","category":"section"},{"location":"docstrings/#FermionicHilbertSpaces.hc","page":"Functions","title":"FermionicHilbertSpaces.hc","text":"hc\n\nAdding this is equivalent to adding the hermitian conjugate.\n\n\n\n\n\n","category":"constant"},{"location":"docstrings/#FermionicHilbertSpaces.FockHilbertSpace","page":"Functions","title":"FermionicHilbertSpaces.FockHilbertSpace","text":"FockHilbertSpace\n\nA type representing a Fock Hilbert space with a given set of modes and Fock states.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#FermionicHilbertSpaces.FockNumber","page":"Functions","title":"FermionicHilbertSpaces.FockNumber","text":"FockNumber\n\nA type representing a Fock state as the bitstring of an integer.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#FermionicHilbertSpaces.FockSymmetry","page":"Functions","title":"FermionicHilbertSpaces.FockSymmetry","text":"struct FockSymmetry{IF,FI,QN,QNfunc} <: AbstractSymmetry\n\nFockSymmetry represents a symmetry that is diagonal in fock space, i.e. particle number conservation, parity, spin conservation.\n\nFields\n\nbasisstates::IF: A vector of Fock numbers, which are integers representing the occupation of each mode.\nstate_indexdict::FI: A dictionary mapping Fock states to indices.\nqntofockstates::Dictionary{QN,Vector{Int}}: A dictionary mapping quantum numbers to Fock states.\nconserved_quantity::QNfunc: A function that computes the conserved quantity from a fock number.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#FermionicHilbertSpaces.FockSymmetryFunction","page":"Functions","title":"FermionicHilbertSpaces.FockSymmetryFunction","text":"FockSymmetryFunction{F} <: AbstractSymmetry\n\nFockSymmetryFunction represents a symmetry defined by a function that maps Fock states to quantum numbers. The function should return 'missing' for states which should be discarded from the hilbert space.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#FermionicHilbertSpaces.HC","page":"Functions","title":"FermionicHilbertSpaces.HC","text":"HC\n\nRepresents the Hermitian conjugate.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#FermionicHilbertSpaces.JordanWignerOrdering","page":"Functions","title":"FermionicHilbertSpaces.JordanWignerOrdering","text":"JordanWignerOrdering\n\nA type representing the ordering of fermionic modes.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#FermionicHilbertSpaces.NoSymmetry","page":"Functions","title":"FermionicHilbertSpaces.NoSymmetry","text":"NoSymmetry\n\nA symmetry type indicating no symmetry constraints.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#FermionicHilbertSpaces.NumberConservation","page":"Functions","title":"FermionicHilbertSpaces.NumberConservation","text":"NumberConservation\n\nA symmetry type representing conservation of total fermion number.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#FermionicHilbertSpaces.ParityConservation","page":"Functions","title":"FermionicHilbertSpaces.ParityConservation","text":"ParityConservation\n\nA symmetry type representing conservation of fermion parity.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#FermionicHilbertSpaces.SimpleFockHilbertSpace","page":"Functions","title":"FermionicHilbertSpaces.SimpleFockHilbertSpace","text":"SimpleFockHilbertSpace\n\nA type representing a simple Fock Hilbert space with all fock states included.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#FermionicHilbertSpaces.SymmetricFockHilbertSpace","page":"Functions","title":"FermionicHilbertSpaces.SymmetricFockHilbertSpace","text":"SymmetricFockHilbertSpace\n\nA type representing a Fock Hilbert space with fockstates organized by their quantum number.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#FermionicHilbertSpaces.basisstates-Union{Tuple{SimpleFockHilbertSpace{F}}, Tuple{F}} where F","page":"Functions","title":"FermionicHilbertSpaces.basisstates","text":"basisstates(H)\n\nReturn an iterator over all basis states for the given Hilbert space H.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#FermionicHilbertSpaces.bdg_hilbert_space-Tuple{Any}","page":"Functions","title":"FermionicHilbertSpaces.bdg_hilbert_space","text":"bdg_hilbert_space(labels)\n\nThis hilbert space uses Nambu states to describe non-interacting systems with superconductive pairing. Matrix representations of quadratic operators take the form \n    [H  Δ;  -Δ*  -H*] \nwhere H is hermitian and Δ is antisymmetric.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#FermionicHilbertSpaces.embed-Tuple{Any, Pair{<:FermionicHilbertSpaces.AbstractHilbertSpace, <:FermionicHilbertSpaces.AbstractHilbertSpace}}","page":"Functions","title":"FermionicHilbertSpaces.embed","text":"embed(m, Hsub => H; complement=complementary_subsystem(H, Hsub), kwargs...)\n\nCompute the embedding of a matrix m in the basis Hsub into the basis H. Fermionic phase factors are included if the two spaces are fermionic Hilbert spaces. \n\n\n\n\n\n","category":"method"},{"location":"docstrings/#FermionicHilbertSpaces.embed-Tuple{Pair{<:FermionicHilbertSpaces.AbstractHilbertSpace, <:FermionicHilbertSpaces.AbstractHilbertSpace}}","page":"Functions","title":"FermionicHilbertSpaces.embed","text":"embed(Hsub => H; kwargs...)\n\nCompute the embedding map from Hsub into H. Fermionic phase factors are included if the two spaces are fermionic Hilbert spaces. \n\n\n\n\n\n","category":"method"},{"location":"docstrings/#FermionicHilbertSpaces.embedding_unitary-Tuple{Any, Any, JordanWignerOrdering}","page":"Functions","title":"FermionicHilbertSpaces.embedding_unitary","text":"embedding_unitary(partition, basisstates, jw)\n\nCompute the unitary matrix that maps between the tensor embedding and the fermionic embedding in the physical subspace. \n# Arguments\n- `partition`: A partition of the labels in `jw` into disjoint sets.\n- `basisstates`: The basis states in the basis\n- `jw`: The Jordan-Wigner ordering.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#FermionicHilbertSpaces.eval_in_basis-Tuple{FermionicHilbertSpaces.FermionSym, Any}","page":"Functions","title":"FermionicHilbertSpaces.eval_in_basis","text":"eval_in_basis(a, f)\n\nEvaluate an expression with fermions in a basis f. \n\nExamples\n\n@fermions a\nf = fermions(hilbert_space(1:2))\nFermionicHilbertSpaces.eval_in_basis(a[1]'*a[2] + hc, f)\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#FermionicHilbertSpaces.extend","page":"Functions","title":"FermionicHilbertSpaces.extend","text":"extend(H => Hbar, Hout = tensor_product((H, Hbar)); kwargs...)\n\nCompute the extend map from H into a disjoint space Hbar.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#FermionicHilbertSpaces.extend-2","page":"Functions","title":"FermionicHilbertSpaces.extend","text":"extend(m, H => Hbar, Hout = tensor_product((H, Hbar)); kwargs...)\n\nExtend an operator or state m from Hilbert space H into a disjoint space Hbar.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#FermionicHilbertSpaces.fermion_sparse_matrix-Tuple{Any, FermionicHilbertSpaces.AbstractFockHilbertSpace}","page":"Functions","title":"FermionicHilbertSpaces.fermion_sparse_matrix","text":"fermion_sparse_matrix(fermion_number, H::AbstractFockHilbertSpace)\n\nConstructs a sparse matrix of size representing a fermionic annihilation operator at bit position fermion_number on the Hilbert space H. \n\n\n\n\n\n","category":"method"},{"location":"docstrings/#FermionicHilbertSpaces.fermions-Tuple{FermionicHilbertSpaces.AbstractFockHilbertSpace}","page":"Functions","title":"FermionicHilbertSpaces.fermions","text":"fermions(H)\n\nReturn a dictionary of fermionic annihilation operators for the Hilbert space H.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#FermionicHilbertSpaces.fixed_particle_number_fockstates-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T","page":"Functions","title":"FermionicHilbertSpaces.fixed_particle_number_fockstates","text":"fixed_particle_number_fockstates(M, n)\n\nGenerate a list of Fock states with n occupied fermions in a system with M different fermions.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#FermionicHilbertSpaces.focksymmetry-Tuple{Any, Any}","page":"Functions","title":"FermionicHilbertSpaces.focksymmetry","text":"focksymmetry(basisstates, qn)\n\nConstructs a FockSymmetry object that represents the symmetry of a many-body system. \n\nArguments\n\nbasisstates: The basisstates to iterate over\nqn: A function that takes an integer representing a fock state and returns corresponding quantum number.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#FermionicHilbertSpaces.generalized_kron","page":"Functions","title":"FermionicHilbertSpaces.generalized_kron","text":"generalized_kron(ms, Hs, H::AbstractHilbertSpace=tensor_product(Hs))\n\nCompute the tensor product of matrices or vectors in ms with respect to the spaces Hs, respectively. Return a matrix in the space H, which defaults to the tensor_product product of Hs.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#FermionicHilbertSpaces.hilbert_space-Tuple{Any}","page":"Functions","title":"FermionicHilbertSpaces.hilbert_space","text":"hilbert_space(labels[, symmetry, basisstates])\n\nConstruct a Hilbert space from a set of labels, with optional symmetry and Fock number specification.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#FermionicHilbertSpaces.jwstring-Tuple{Any, Any}","page":"Functions","title":"FermionicHilbertSpaces.jwstring","text":"jwstring(site, focknbr)\n\nParity of the number of fermions to the right of site.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#FermionicHilbertSpaces.majorana_hilbert_space","page":"Functions","title":"FermionicHilbertSpaces.majorana_hilbert_space","text":"majorana_hilbert_space(labels, qn)\n\nRepresents a hilbert space for majoranas. labels must be an even number of unique labels.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#FermionicHilbertSpaces.majoranas","page":"Functions","title":"FermionicHilbertSpaces.majoranas","text":"majoranas(H)\n\nReturn a dictionary of Majorana operators for the Hilbert space H.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#FermionicHilbertSpaces.matrix_representation-Tuple{Any, FermionicHilbertSpaces.AbstractFockHilbertSpace}","page":"Functions","title":"FermionicHilbertSpaces.matrix_representation","text":"matrix_representation(op, H::AbstractFockHilbertSpace)\n\nReturn the matrix representation of the symbolic operator op on the hilbert space H.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#FermionicHilbertSpaces.number_conservation","page":"Functions","title":"FermionicHilbertSpaces.number_conservation","text":"number_conservation(sectors=missing, weight_function=label -> true)\n\nConstructs a UninstantiatedNumberConservations symmetry object that represents conservation of fermion number. 'sectors' can be an integer or a collection of integers specifying the allowed fermion numbers. 'weight_function' is a function that takes a label and returns an integer weight (which can be negative) indicating how that label contributes to the fermion number.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#FermionicHilbertSpaces.numberoperator-Tuple{FermionicHilbertSpaces.AbstractFockHilbertSpace}","page":"Functions","title":"FermionicHilbertSpaces.numberoperator","text":"numberoperator(H)\n\nReturn the number operator for the Hilbert space H.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#FermionicHilbertSpaces.parityoperator-Tuple{FermionicHilbertSpaces.AbstractFockHilbertSpace}","page":"Functions","title":"FermionicHilbertSpaces.parityoperator","text":"parityoperator(H)\n\nReturn the fermionic parity operator for the Hilbert space H.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#FermionicHilbertSpaces.partial_trace!","page":"Functions","title":"FermionicHilbertSpaces.partial_trace!","text":"partial_trace!(mout, m, H::AbstractHilbertSpace, Hsub::AbstractHilbertSpace, phase_factors::Bool, complement, extend_state=StateExtender((Hsub, complement), H))\n\nCompute the partial trace of m from H to Hsub. \n\n\n\n\n\n","category":"function"},{"location":"docstrings/#FermionicHilbertSpaces.partial_trace-Tuple{Any, Pair{<:FermionicHilbertSpaces.AbstractHilbertSpace, <:FermionicHilbertSpaces.AbstractHilbertSpace}}","page":"Functions","title":"FermionicHilbertSpaces.partial_trace","text":"partial_trace(m, H => Hsub; phase_factors=use_phase_factors(H) && use_phase_factors(Hsub), complement=complementary_subsystem(H, Hsub))\n\nCompute the partial trace of m from H to Hsub. Fermionic phase factors are included if both H and Hsub are Fermionic, unless specified otherwise in kwargs.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#FermionicHilbertSpaces.partial_trace-Tuple{Pair{<:FermionicHilbertSpaces.AbstractHilbertSpace, <:FermionicHilbertSpaces.AbstractHilbertSpace}}","page":"Functions","title":"FermionicHilbertSpaces.partial_trace","text":"partial_trace(H => Hsub; kwargs...)\n\nCompute the partial trace map from H to Hsub, represented by a sparse matrix of dimension dim(Hsub)^2 x dim(H)^2 that can be multiplied with a vectorized density matrix. \n\n\n\n\n\n","category":"method"},{"location":"docstrings/#FermionicHilbertSpaces.removefermion-Tuple{Any, FockNumber}","page":"Functions","title":"FermionicHilbertSpaces.removefermion","text":"removefermion(digitposition, f::FockNumber)\n\nReturn (newfocknbr, fermionstatistics) where newfocknbr is the state obtained by removing a fermion at digitposition from f and fermionstatistics is the phase from the Jordan-Wigner string, or 0 if the operation is not allowed.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#FermionicHilbertSpaces.single_particle_hilbert_space-Tuple{Any}","page":"Functions","title":"FermionicHilbertSpaces.single_particle_hilbert_space","text":"single_particle_hilbert_space(labels)\n\nA hilbert space suitable for non-interacting systems with fermion number conservation. Matrix representations of symbolic operators give the single particle hamiltonian, without any contribution from the identity matrix.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#FermionicHilbertSpaces.subregion-Union{Tuple{F}, Tuple{Any, SimpleFockHilbertSpace{F}}} where F","page":"Functions","title":"FermionicHilbertSpaces.subregion","text":"subregion(modes, H::AbstractHilbertSpace)\n\nReturn a subregion of the Hilbert space H that is spanned by the modes in modes. Only substates in H are included.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#FermionicHilbertSpaces.tensor_product-Tuple{AbstractVector{<:FermionicHilbertSpaces.AbstractHilbertSpace}}","page":"Functions","title":"FermionicHilbertSpaces.tensor_product","text":"tensor_product(Hs)\n\nReturn the tensor product space of hilbert spaces Hs.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#FermionicHilbertSpaces.tensor_product-Tuple{Union{Tuple, AbstractVector}, Any, FermionicHilbertSpaces.AbstractFockHilbertSpace}","page":"Functions","title":"FermionicHilbertSpaces.tensor_product","text":"tensor_product(ms, Hs, H::AbstractHilbertSpace; kwargs...)\n\nCompute the ordered product of the fermionic embeddings of the matrices ms in the spaces Hs into the space H. kwargs can be passed a bool phase_factors and a hilbert space complement.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#FermionicHilbertSpaces.togglefermions-Union{Tuple{I}, Tuple{Any, Any, FockNumber{I}}} where I","page":"Functions","title":"FermionicHilbertSpaces.togglefermions","text":"togglefermions(digitpositions, daggers, f::FockNumber)\n\nReturn (newfocknbr, fermionstatistics) where newfocknbr is the state obtained by toggling fermions at digitpositions with daggers in the Fock state f, and fermionstatistics is the phase from the Jordan-Wigner string. If the operation puts two fermions one the same site, the resulting state is undefined.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#FermionicHilbertSpaces.@fermions-Tuple","page":"Functions","title":"FermionicHilbertSpaces.@fermions","text":"@fermions a b ...\n\nCreate one or more fermion species with the given names. Indexing into fermions species gives a concrete fermion. Fermions in one @fermions block anticommute with each other,  and commute with fermions in other @fermions blocks.\n\nExamples:\n\n@fermions a b creates two species of fermions that anticommute:\na[1]' * a[1] + a[1] * a[1]' == 1\na[1]' * b[1] + b[1] * a[1]' == 0\n@fermions a; @fermions b creates two species of fermions that commute with each other:\na[1]' * a[1] + a[1] * a[1]' == 1\na[1] * b[1] - b[1] * a[1] == 0\n\nSee also @majoranas, FermionicHilbertSpaces.eval_in_basis.\n\n\n\n\n\n","category":"macro"},{"location":"docstrings/#FermionicHilbertSpaces.@majoranas-Tuple","page":"Functions","title":"FermionicHilbertSpaces.@majoranas","text":"@majoranas a b ...\n\nCreate one or more Majorana species with the given names. Indexing into Majorana species gives a concrete Majorana. Majoranas in one @majoranas block anticommute with each other, and commute with Majoranas in other @majoranas blocks.\n\nExamples:\n\n@majoranas a b creates two species of Majoranas that anticommute:\na[1] * a[1] + a[1] * a[1] == 1\na[1] * b[1] + b[1] * a[1] == 0\n@majoranas a; @majoranas b creates two species of Majoranas that commute with each other:\na[1] * a[1] + a[1] * a[1] == 1\na[1] * b[1] - b[1] * a[1] == 0\n\nSee also @fermions, FermionicHilbertSpaces.eval_in_basis.\n\n\n\n\n\n","category":"macro"}]
}
