var documenterSearchIndex = {"docs":
[{"location":"#FermionicHilbertSpaces","page":"Home","title":"FermionicHilbertSpaces","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for FermionicHilbertSpaces.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#FermionicHilbertSpaces.FockSymmetry","page":"Home","title":"FermionicHilbertSpaces.FockSymmetry","text":"struct FockSymmetry{IF,FI,QN,QNfunc} <: AbstractSymmetry\n\nFockSymmetry represents a symmetry that is diagonal in fock space, i.e. particle number conservation, parity, spin consvervation.\n\nFields\n\nindtofockdict::IF: A dictionary mapping indices to Fock states.\nfocktoinddict::FI: A dictionary mapping Fock states to indices.\nqntoblocksizes::Dictionary{QN,Int}: A dictionary mapping quantum numbers to block sizes.\nqntofockstates::Dictionary{QN,Vector{Int}}: A dictionary mapping quantum numbers to Fock states.\nqntoinds::Dictionary{QN,Vector{Int}}: A dictionary mapping quantum numbers to indices.\nconserved_quantity::QNfunc: A function that computes the conserved quantity from a fock number.\n\n\n\n\n\n","category":"type"},{"location":"#FermionicHilbertSpaces.embedding","page":"Home","title":"FermionicHilbertSpaces.embedding","text":"embedding(m, H, Hnew)\n\nCompute the fermionic embedding of a matrix m in the basis H into the basis Hnew.\n\n\n\n\n\n","category":"function"},{"location":"#FermionicHilbertSpaces.embedding_unitary-Tuple{Any, Any, JordanWignerOrdering}","page":"Home","title":"FermionicHilbertSpaces.embedding_unitary","text":"embedding_unitary(partition, fockstates, jw)\n\nCompute the unitary matrix that maps between the tensor embedding and the fermionic embedding in the physical subspace. \n# Arguments\n- `partition`: A partition of the labels in `jw` into disjoint sets.\n- `fockstates`: The fock states in the basis\n- `jw`: The Jordan-Wigner ordering.\n\n\n\n\n\n","category":"method"},{"location":"#FermionicHilbertSpaces.eval_in_basis-Tuple{FermionicHilbertSpaces.FermionSym, Any}","page":"Home","title":"FermionicHilbertSpaces.eval_in_basis","text":"eval_in_basis(a, f)\n\nEvaluate an expression with fermions in a basis f. \n\nExamples\n\n@fermions a\nf = fermions(hilbert_space(1:2))\nFermionicHilbertSpaces.eval_in_basis(a[1]'*a[2] + hc, f)\n\n\n\n\n\n","category":"method"},{"location":"#FermionicHilbertSpaces.fermion_sparse_matrix-Tuple{Any, FermionicHilbertSpaces.AbstractFockHilbertSpace}","page":"Home","title":"FermionicHilbertSpaces.fermion_sparse_matrix","text":"fermion_sparse_matrix(fermion_number, H::AbstractFockHilbertSpace)\n\nConstructs a sparse matrix of size representing a fermionic annihilation operator at bit position fermion_number on the Hilbert space H. \n\n\n\n\n\n","category":"method"},{"location":"#FermionicHilbertSpaces.fermionic_kron","page":"Home","title":"FermionicHilbertSpaces.fermionic_kron","text":"fermionic_kron(ms::AbstractVector, Hs::AbstractVector{<:AbstractHilbertSpace}, H::AbstractHilbertSpace=tensor_product(bs))\n\nCompute the fermionic tensor product of matrices or vectors in ms with respect to the fermion bases bs, respectively. Return a matrix in the fermion basis b, which defaults to the tensor_product product of bs.\n\n\n\n\n\n","category":"function"},{"location":"#FermionicHilbertSpaces.fockstates-Tuple{Any, Any}","page":"Home","title":"FermionicHilbertSpaces.fockstates","text":"fockstates(M, n)\n\nGenerate a list of Fock states with n occupied fermions in a system with M different fermions.\n\n\n\n\n\n","category":"method"},{"location":"#FermionicHilbertSpaces.focksymmetry-Tuple{Any, Any}","page":"Home","title":"FermionicHilbertSpaces.focksymmetry","text":"focksymmetry(focknumbers, qn)\n\nConstructs a FockSymmetry object that represents the symmetry of a many-body system. \n\nArguments\n\nfocknumbers: The focknumbers to iterate over\nqn: A function that takes an integer representing a fock state and returns corresponding quantum number.\n\n\n\n\n\n","category":"method"},{"location":"#FermionicHilbertSpaces.jwstring-Tuple{Any, Any}","page":"Home","title":"FermionicHilbertSpaces.jwstring","text":"jwstring(site, focknbr)\n\nParity of the number of fermions to the right of site.\n\n\n\n\n\n","category":"method"},{"location":"#FermionicHilbertSpaces.numberoperator-Tuple{FermionicHilbertSpaces.AbstractFockHilbertSpace}","page":"Home","title":"FermionicHilbertSpaces.numberoperator","text":"numberoperator(basis::AbstractFockHilbertSpace)\n\nReturn the number operator of H.\n\n\n\n\n\n","category":"method"},{"location":"#FermionicHilbertSpaces.parityoperator-Tuple{FermionicHilbertSpaces.AbstractFockHilbertSpace}","page":"Home","title":"FermionicHilbertSpaces.parityoperator","text":"parityoperator(H::AbstractFockHilbertSpace)\n\nReturn the parity operator of H.\n\n\n\n\n\n","category":"method"},{"location":"#FermionicHilbertSpaces.partial_trace!","page":"Home","title":"FermionicHilbertSpaces.partial_trace!","text":"partial_trace!(mout, m::AbstractMatrix, H::AbstractHilbertSpace, Hout::AbstractHilbertSpace, phase_factors)\n\nCompute the fermionic partial trace of a matrix m in basis H, leaving only the subsystems specified by labels. The result is stored in mout, and Hout determines the ordering of the basis states.\n\n\n\n\n\n","category":"function"},{"location":"#FermionicHilbertSpaces.partial_trace-Union{Tuple{T}, Tuple{AbstractMatrix{T}, FermionicHilbertSpaces.AbstractHilbertSpace, FermionicHilbertSpaces.AbstractHilbertSpace}, Tuple{AbstractMatrix{T}, FermionicHilbertSpaces.AbstractHilbertSpace, FermionicHilbertSpaces.AbstractHilbertSpace, Any}} where T","page":"Home","title":"FermionicHilbertSpaces.partial_trace","text":"partial_trace(m::AbstractMatrix,  bHfull::AbstractHilbertSpace, Hsub::AbstractHilbertSpace)\n\nCompute the partial trace of a matrix m, leaving the subsystem defined by the basis bsub.\n\n\n\n\n\n","category":"method"},{"location":"#FermionicHilbertSpaces.removefermion-Tuple{Any, FockNumber}","page":"Home","title":"FermionicHilbertSpaces.removefermion","text":"removefermion(digitposition, f::FockNumber)\n\nReturn (newfocknbr, fermionstatistics) where newfocknbr is the state obtained by removing a fermion at digitposition from f and fermionstatistics is the phase from the Jordan-Wigner string, or 0 if the operation is not allowed.\n\n\n\n\n\n","category":"method"},{"location":"#FermionicHilbertSpaces.tensor_product-Tuple{AbstractVector{<:FermionicHilbertSpaces.AbstractHilbertSpace}}","page":"Home","title":"FermionicHilbertSpaces.tensor_product","text":"tensor_product(bs)\n\nCompute the tensorproduct product of a list of FermionBasis objects. The symmetry of the resulting basis is computed by promotesymmetry.\n\n\n\n\n\n","category":"method"},{"location":"#FermionicHilbertSpaces.tensor_product-Tuple{Any, Any, Any}","page":"Home","title":"FermionicHilbertSpaces.tensor_product","text":"tensor_product(ms, bs, b)\n\nCompute the ordered product of the fermionic embeddings of the matrices ms in the bases bs into the basis b.\n\n\n\n\n\n","category":"method"},{"location":"#FermionicHilbertSpaces.@fermions-Tuple","page":"Home","title":"FermionicHilbertSpaces.@fermions","text":"@fermions a b ...\n\nCreate one or more fermion species with the given names. Indexing into fermions species gives a concrete fermion. Fermions in one @fermions block anticommute with each other,  and commute with fermions in other @fermions blocks.\n\nExamples:\n\n@fermions a b creates two species of fermions that anticommute:\na[1]' * a[1] + a[1] * a[1]' == 1\na[1]' * b[1] + b[1] * a[1]' == 0\n@fermions a; @fermions b creates two species of fermions that commute with each other:\na[1]' * a[1] + a[1] * a[1]' == 1\na[1] * b[1] - b[1] * a[1] == 0\n\nSee also @majoranas, FermionicHilbertSpaces.eval_in_basis.\n\n\n\n\n\n","category":"macro"},{"location":"#FermionicHilbertSpaces.@majoranas-Tuple","page":"Home","title":"FermionicHilbertSpaces.@majoranas","text":"@majoranas a b ...\n\nCreate one or more Majorana species with the given names. Indexing into Majorana species gives a concrete Majorana. Majoranas in one @majoranas block anticommute with each other, and commute with Majoranas in other @majoranas blocks.\n\nExamples:\n\n@majoranas a b creates two species of Majoranas that anticommute:\na[1] * a[1] + a[1] * a[1] == 1\na[1] * b[1] + b[1] * a[1] == 0\n@majoranas a; @majoranas b creates two species of Majoranas that commute with each other:\na[1] * a[1] + a[1] * a[1] == 1\na[1] * b[1] - b[1] * a[1] == 0\n\nSee also @fermions, FermionicHilbertSpaces.eval_in_basis.\n\n\n\n\n\n","category":"macro"}]
}
